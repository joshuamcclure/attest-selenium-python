{
  "rules": [
    {
      "id": "ui-alert-has-alert-role",
      "selector": "ui-alert",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
          "has-alert-role"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "UI Alert elements should have an alert role.",
        "description": "Ensures proper notifications are provided to users when form field validations issues occur."
      }
    },
    {
      "id": "accesskeys",
      "selector": "[accesskey]",
      "excludeHidden": false,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "accesskeys"
      ],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "accesskey attribute value must be unique",
        "description": "Ensures every accesskey attribute value is unique"
      }
    },
    {
      "id": "area-alt",
      "selector": "map area[href]",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "non-empty-alt",
        "non-empty-title",
        "aria-label",
        "aria-labelledby"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag111",
        "wcag244",
        "wcag412",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "Active <area> elements must have alternate text",
        "description": "Ensures <area> elements of image maps have alternate text",
        "mapping": {
          "ruleId": "010109-A",
          "SC": "1.1.1",
          "weight": 3,
          "description": "Missing text equivalent for area."
        }
      }
    },
    {
      "id": "aria-allowed-attr",
      "selector": "*",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-allowed-attr"
      ],
      "all": [],
      "none": [
        "aria-unsupported-attr"
      ],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var aria = /^aria-/;\n        if (node.hasAttributes()) {\n          var attrs = axe.utils.getNodeAttributes(node);\n          for (var i = 0, l = attrs.length; i < l; i++) {\n            if (aria.test(attrs[i].name)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }",
      "metadata": {
        "help": "Elements must only use allowed ARIA attributes",
        "description": "Ensures ARIA attributes are allowed for an element's role",
        "mapping": {
          "ruleId": "ARIA_ATTRIBUTE_VALID",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Checks all attributes that start with 'aria-' to ensure that they are all official WAI-ARIA attributes"
        }
      }
    },
    {
      "id": "aria-allowed-role",
      "selector": "[role]",
      "excludeHidden": false,
      "enabled": false,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "allowImplicit": true,
            "ignoredTags": []
          },
          "id": "aria-allowed-role"
        }
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return axe.commons.aria.getRole(node, {\n          noImplicit: true,\n          dpub: true,\n          fallback: true\n        }) !== null;\n      }",
      "metadata": {
        "help": "ARIA role must be appropriate for the element",
        "description": "Ensures role attribute has an appropriate value for the element"
      }
    },
    {
      "id": "aria-dpub-role-fallback",
      "selector": "[role]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        "implicit-role-fallback"
      ],
      "none": [],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag131",
        "deprecated"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var role = node.getAttribute('role');\n        return [ 'doc-backlink', 'doc-biblioentry', 'doc-biblioref', 'doc-cover', 'doc-endnote', 'doc-glossref', 'doc-noteref' ].includes(role);\n      }",
      "metadata": {
        "help": "Unsupported DPUB ARIA roles should be used on elements with implicit fallback roles",
        "description": "Ensures unsupported DPUB roles are only used on elements with implicit fallback roles"
      }
    },
    {
      "id": "aria-hidden-body",
      "selector": "body",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-hidden-body"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "metadata": {
        "help": "aria-hidden='true' must not be present on the document body",
        "description": "Ensures aria-hidden='true' is not present on the document body."
      }
    },
    {
      "id": "aria-hidden-focus",
      "selector": "[aria-hidden=\"true\"]",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        "focusable-modal-open",
        "focusable-disabled",
        "focusable-not-tabbable"
      ],
      "none": [],
      "tags": [
        "cat.name-role-value",
        "wcag2a",
        "wcag412",
        "wcag131"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var getComposedParent = axe.commons.dom.getComposedParent;\n        function shouldMatchElement(el) {\n          if (!el) {\n            return true;\n          }\n          if (el.getAttribute('aria-hidden') === 'true') {\n            return false;\n          }\n          return shouldMatchElement(getComposedParent(el));\n        }\n        return shouldMatchElement(getComposedParent(node));\n      }",
      "metadata": {
        "help": "ARIA hidden element must not contain focusable elements",
        "description": "Ensures aria-hidden elements do not contain focusable elements"
      }
    },
    {
      "id": "aria-input-field-name",
      "selector": "[role=\"combobox\"], [role=\"listbox\"], [role=\"searchbox\"], [role=\"slider\"], [role=\"spinbutton\"], [role=\"textbox\"]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-label",
        "aria-labelledby",
        "non-empty-title"
      ],
      "all": [],
      "none": [
        "no-implicit-explicit-label"
      ],
      "tags": [
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var aria = axe.commons.aria;\n        var nodeName = node.nodeName.toUpperCase();\n        var role = aria.getRole(node, {\n          noImplicit: true\n        });\n        if (nodeName === 'AREA' && !!node.getAttribute('href')) {\n          return false;\n        }\n        if ([ 'INPUT', 'SELECT', 'TEXTAREA' ].includes(nodeName)) {\n          return false;\n        }\n        if (nodeName === 'IMG' || role === 'img' && nodeName !== 'SVG') {\n          return false;\n        }\n        if (nodeName === 'BUTTON' || role === 'button') {\n          return false;\n        }\n        if (role === 'combobox' && axe.utils.querySelectorAll(virtualNode, 'input:not([type=\"hidden\"])').length) {\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "help": "ARIA input fields have an accessible name",
        "description": "Ensures every ARIA input field has an accessible name"
      }
    },
    {
      "id": "aria-required-attr",
      "selector": "[role]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-required-attr"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "metadata": {
        "help": "Required ARIA attributes must be provided",
        "description": "Ensures elements with ARIA roles have all required ARIA attributes",
        "mapping": {
          "ruleId": "ARIA_ROLE_REQUIRED_ATTRIBUTES",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Checks all elements that contain WAI-ARIA roles to ensure that all required aria- attributes are present"
        }
      }
    },
    {
      "id": "aria-required-children",
      "selector": "[role]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "reviewEmpty": [
              "doc-bibliography",
              "doc-endnotes",
              "grid",
              "list",
              "listbox",
              "table",
              "tablist",
              "tree",
              "treegrid",
              "rowgroup"
            ]
          },
          "id": "aria-required-children"
        }
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag131"
      ],
      "preload": false,
      "metadata": {
        "help": "Certain ARIA roles must contain particular children",
        "description": "Ensures elements with an ARIA role that require child roles contain them",
        "mapping": {
          "ruleId": "ARIA_ROLE_REQUIRED_CHILDREN",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Checks all elements that contain a WAI-ARIA role to ensure that all required children roles are present"
        }
      }
    },
    {
      "id": "aria-required-parent",
      "selector": "[role]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-required-parent"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag131"
      ],
      "preload": false,
      "metadata": {
        "help": "Certain ARIA roles must be contained by particular parents",
        "description": "Ensures elements with an ARIA role that require parent roles are contained by them",
        "mapping": {
          "ruleId": "ARIA_ROLE_REQUIRED_PARENTS",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Checks all elements that contain a WAI-ARIA role to ensure that all required parent roles are present"
        }
      }
    },
    {
      "id": "aria-roledescription",
      "selector": "[aria-roledescription]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "supportedRoles": [
              "button",
              "img",
              "checkbox",
              "radio",
              "combobox",
              "menuitemcheckbox",
              "menuitemradio"
            ]
          },
          "id": "aria-roledescription"
        }
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "metadata": {
        "help": "Use aria-roledescription on elements with a semantic role",
        "description": "Ensure aria-roledescription is only used on elements with an implicit or explicit role"
      }
    },
    {
      "id": "aria-roles",
      "selector": "[role]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "fallbackrole",
        "invalidrole",
        "abstractrole",
        "unsupportedrole"
      ],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        if (!virtualNode.hasAttr('role')) {\n          return false;\n        }\n        if (!virtualNode.attr('role').trim()) {\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "help": "ARIA roles used must conform to valid values",
        "description": "Ensures all elements with a role attribute use a valid value",
        "mapping": {
          "ruleId": "ARIA_ROLE_VALID",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Checks all elements that contain the WAI-ARIA role attribute to ensure that the role value is valid"
        }
      }
    },
    {
      "id": "aria-toggle-field-name",
      "selector": "[role=\"checkbox\"], [role=\"menuitemcheckbox\"], [role=\"menuitemradio\"], [role=\"radio\"], [role=\"switch\"]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-label",
        "aria-labelledby",
        "non-empty-title",
        "has-visible-text"
      ],
      "all": [],
      "none": [
        "no-implicit-explicit-label"
      ],
      "tags": [
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var aria = axe.commons.aria;\n        var nodeName = node.nodeName.toUpperCase();\n        var role = aria.getRole(node, {\n          noImplicit: true\n        });\n        if (nodeName === 'AREA' && !!node.getAttribute('href')) {\n          return false;\n        }\n        if ([ 'INPUT', 'SELECT', 'TEXTAREA' ].includes(nodeName)) {\n          return false;\n        }\n        if (nodeName === 'IMG' || role === 'img' && nodeName !== 'SVG') {\n          return false;\n        }\n        if (nodeName === 'BUTTON' || role === 'button') {\n          return false;\n        }\n        if (role === 'combobox' && axe.utils.querySelectorAll(virtualNode, 'input:not([type=\"hidden\"])').length) {\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "help": "ARIA toggle fields have an accessible name",
        "description": "Ensures every ARIA toggle field has an accessible name"
      }
    },
    {
      "id": "aria-valid-attr-value",
      "selector": "*",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        {
          "options": [],
          "id": "aria-valid-attr-value"
        },
        "aria-errormessage"
      ],
      "none": [],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var aria = /^aria-/;\n        if (node.hasAttributes()) {\n          var attrs = axe.utils.getNodeAttributes(node);\n          for (var i = 0, l = attrs.length; i < l; i++) {\n            if (aria.test(attrs[i].name)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }",
      "metadata": {
        "help": "ARIA attributes must conform to valid values",
        "description": "Ensures all ARIA attributes have valid values",
        "mapping": {
          "ruleId": "ARIA_ATTRIBUTE_VALUES",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Checks all elements that contain WAI-ARIA atributes to ensure that the values of the attributes are valid"
        }
      }
    },
    {
      "id": "aria-valid-attr",
      "selector": "*",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        {
          "options": [],
          "id": "aria-valid-attr"
        }
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.aria",
        "wcag2a",
        "wcag412"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var aria = /^aria-/;\n        if (node.hasAttributes()) {\n          var attrs = axe.utils.getNodeAttributes(node);\n          for (var i = 0, l = attrs.length; i < l; i++) {\n            if (aria.test(attrs[i].name)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }",
      "metadata": {
        "help": "ARIA attributes must conform to valid names",
        "description": "Ensures attributes that begin with aria- are valid ARIA attributes",
        "mapping": {
          "ruleId": "ARIA_ATTRIBUTE_VALID",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Checks all elements that contain WAI-ARIA attributes to ensure that the attributes are valid attributes"
        }
      }
    },
    {
      "id": "audio-caption",
      "selector": "audio",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "caption"
      ],
      "tags": [
        "cat.time-and-media",
        "wcag2a",
        "wcag121",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "<audio> elements must have a captions track",
        "description": "Ensures <audio> elements have captions",
        "mapping": {
          "ruleId": "010402-D",
          "SC": "1.2.2",
          "weight": 0,
          "description": "Checks the use of all <audio> element to ensure that the element contains a <caption> element"
        }
      }
    },
    {
      "id": "autocomplete-valid",
      "selector": "*",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [
        "autocomplete-valid",
        "autocomplete-appropriate"
      ],
      "none": [],
      "tags": [
        "cat.forms",
        "wcag21aa",
        "wcag135"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var _axe$commons = axe.commons, text = _axe$commons.text, aria = _axe$commons.aria, dom = _axe$commons.dom;\n        var autocomplete = virtualNode.attr('autocomplete');\n        if (!autocomplete || text.sanitize(autocomplete) === '') {\n          return false;\n        }\n        var nodeName = virtualNode.props.nodeName;\n        if ([ 'textarea', 'input', 'select' ].includes(nodeName) === false) {\n          return false;\n        }\n        var excludedInputTypes = [ 'submit', 'reset', 'button', 'hidden' ];\n        if (nodeName === 'input' && excludedInputTypes.includes(virtualNode.props.type)) {\n          return false;\n        }\n        var ariaDisabled = virtualNode.attr('aria-disabled') || 'false';\n        if (virtualNode.hasAttr('disabled') || ariaDisabled.toLowerCase() === 'true') {\n          return false;\n        }\n        var role = virtualNode.attr('role');\n        var tabIndex = virtualNode.attr('tabindex');\n        if (tabIndex === '-1' && role) {\n          var roleDef = aria.lookupTable.role[role];\n          if (roleDef === undefined || roleDef.type !== 'widget') {\n            return false;\n          }\n        }\n        if (tabIndex === '-1' && virtualNode.actualNode && !dom.isVisible(virtualNode.actualNode, false) && !dom.isVisible(virtualNode.actualNode, true)) {\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "help": "autocomplete attribute must be used correctly",
        "description": "Ensure the autocomplete attribute is correct and suitable for the form field"
      }
    },
    {
      "id": "avoid-inline-spacing",
      "selector": "[style]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [
        "avoid-inline-spacing"
      ],
      "none": [],
      "tags": [
        "wcag21aa",
        "wcag1412"
      ],
      "preload": false,
      "metadata": {
        "help": "Inline text spacing must be adjustable with custom stylesheets",
        "description": "Ensure that text spacing set through style attributes can be adjusted with custom stylesheets"
      }
    },
    {
      "id": "blink",
      "selector": "blink",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "is-on-screen"
      ],
      "tags": [
        "cat.time-and-media",
        "wcag2a",
        "wcag222",
        "section508",
        "section508.22.j"
      ],
      "preload": false,
      "metadata": {
        "help": "<blink> elements are deprecated and must not be used",
        "description": "Ensures <blink> elements are not used",
        "mapping": {
          "ruleId": "070201-A",
          "SC": "2.2.2",
          "weight": 0,
          "description": "Checks to make sure that the <blink> tag is never used"
        }
      }
    },
    {
      "id": "button-name",
      "selector": "button, [role=\"button\"]:not(input)",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "button-has-visible-text",
        "aria-label",
        "aria-labelledby",
        "role-presentation",
        "role-none",
        "non-empty-title"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.name-role-value",
        "wcag2a",
        "wcag412",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "Buttons must have discernible text",
        "description": "Ensures buttons have discernible text",
        "mapping": {
          "ruleId": "SC412BTN",
          "SC": "1.1.1",
          "weight": 3,
          "description": "Checks all <button> elements to ensure that they have a discernable accessible name"
        }
      }
    },
    {
      "id": "bypass",
      "selector": "html",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": true,
      "any": [
        "internal-link-present",
        "header-present",
        "landmark"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.keyboard",
        "wcag2a",
        "wcag241",
        "section508",
        "section508.22.o"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return !!node.querySelector('a[href]');\n      }",
      "metadata": {
        "help": "Page must have means to bypass repeated blocks",
        "description": "Ensures each page has at least one mechanism for a user to bypass navigation and jump straight to the content",
        "mapping": {
          "ruleId": "N130601-A",
          "SC": "2.4.1",
          "weight": 3,
          "description": "There is no mechanism to bypass navigation links."
        }
      }
    },
    {
      "id": "checkboxgroup",
      "selector": "input[type=checkbox][name]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "group-labelledby",
        "fieldset"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Checkbox inputs with the same name attribute value must be part of a group",
        "description": "Ensures related <input type=\"checkbox\"> elements have a group and that the group designation is consistent",
        "mapping": {
          "ruleId": "SC131GROUP",
          "SC": "1.3.1",
          "weight": 3,
          "description": "Ensures that all checkbox groups have a group and that that group designation is consistent"
        }
      }
    },
    {
      "id": "color-contrast",
      "selector": "*",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "noScroll": false,
            "ignoreUnicode": true,
            "ignoreLength": false
          },
          "id": "color-contrast"
        }
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.color",
        "wcag2aa",
        "wcag143"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var nodeName = node.nodeName.toUpperCase();\n        var nodeType = node.type;\n        if (node.getAttribute('aria-disabled') === 'true' || axe.commons.dom.findUpVirtual(virtualNode, '[aria-disabled=\"true\"]')) {\n          return false;\n        }\n        var formElements = [ 'INPUT', 'SELECT', 'TEXTAREA' ];\n        if (formElements.includes(nodeName)) {\n          var style = window.getComputedStyle(node);\n          var textIndent = parseInt(style.getPropertyValue('text-indent'), 10);\n          if (textIndent) {\n            var rect = node.getBoundingClientRect();\n            rect = {\n              top: rect.top,\n              bottom: rect.bottom,\n              left: rect.left + textIndent,\n              right: rect.right + textIndent\n            };\n            if (!axe.commons.dom.visuallyOverlaps(rect, node)) {\n              return false;\n            }\n          }\n        }\n        if (nodeName === 'INPUT') {\n          return [ 'hidden', 'range', 'color', 'checkbox', 'radio', 'image' ].indexOf(nodeType) === -1 && !node.disabled;\n        }\n        if (nodeName === 'SELECT') {\n          return !!node.options.length && !node.disabled;\n        }\n        if (nodeName === 'TEXTAREA') {\n          return !node.disabled;\n        }\n        if (nodeName === 'OPTION') {\n          return false;\n        }\n        if (nodeName === 'BUTTON' && node.disabled || axe.commons.dom.findUpVirtual(virtualNode, 'button[disabled]')) {\n          return false;\n        }\n        if (nodeName === 'FIELDSET' && node.disabled || axe.commons.dom.findUpVirtual(virtualNode, 'fieldset[disabled]')) {\n          return false;\n        }\n        var nodeParentLabel = axe.commons.dom.findUpVirtual(virtualNode, 'label');\n        if (nodeName === 'LABEL' || nodeParentLabel) {\n          var relevantNode = node;\n          var relevantVirtualNode = virtualNode;\n          if (nodeParentLabel) {\n            relevantNode = nodeParentLabel;\n            relevantVirtualNode = axe.utils.getNodeFromTree(nodeParentLabel);\n          }\n          var doc = axe.commons.dom.getRootNode(relevantNode);\n          var candidate = relevantNode.htmlFor && doc.getElementById(relevantNode.htmlFor);\n          var candidateVirtualNode = axe.utils.getNodeFromTree(candidate);\n          if (candidate && (candidate.disabled || candidate.getAttribute('aria-disabled') === 'true' || axe.commons.dom.findUpVirtual(candidateVirtualNode, '[aria-disabled=\"true\"]'))) {\n            return false;\n          }\n          candidate = axe.utils.querySelectorAll(relevantVirtualNode, 'input:not([type=\"hidden\"]):not([type=\"image\"])' + ':not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]), select, textarea');\n          if (candidate.length && candidate[0].actualNode.disabled) {\n            return false;\n          }\n        }\n        if (node.getAttribute('id')) {\n          var id = axe.utils.escapeSelector(node.getAttribute('id'));\n          var _doc = axe.commons.dom.getRootNode(node);\n          var _candidate = _doc.querySelector('[aria-labelledby~=' + id + ']');\n          if (_candidate && _candidate.disabled) {\n            return false;\n          }\n        }\n        var visibleText = axe.commons.text.visibleVirtual(virtualNode, false, true);\n        if (visibleText === '' || axe.commons.text.removeUnicode(visibleText, {\n          emoji: true,\n          nonBmp: false,\n          punctuations: true\n        }) === '') {\n          return false;\n        }\n        var range = document.createRange();\n        var childNodes = virtualNode.children;\n        var length = childNodes.length;\n        var child = null;\n        var index = 0;\n        for (index = 0; index < length; index++) {\n          child = childNodes[index];\n          if (child.actualNode.nodeType === 3 && axe.commons.text.sanitize(child.actualNode.nodeValue) !== '') {\n            range.selectNodeContents(child.actualNode);\n          }\n        }\n        var rects = range.getClientRects();\n        length = rects.length;\n        for (index = 0; index < length; index++) {\n          if (axe.commons.dom.visuallyOverlaps(rects[index], node)) {\n            return true;\n          }\n        }\n        return false;\n      }",
      "metadata": {
        "help": "Elements must have sufficient color contrast",
        "description": "Ensures the contrast between foreground and background colors meets WCAG 2 AA contrast ratio thresholds",
        "mapping": {
          "ruleId": "020201-A",
          "SC": "1.4.3",
          "weight": 2,
          "description": "Checks all elements to ensure that the contrast between the foreground and the background meets the WCAG 2 AA contrast ratio thresholds."
        }
      }
    },
    {
      "id": "css-orientation-lock",
      "selector": "html",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [
        {
          "options": {
            "degreeThreshold": 2
          },
          "id": "css-orientation-lock"
        }
      ],
      "none": [],
      "tags": [],
      "preload": true,
      "metadata": {
        "help": "CSS Media queries are not used to lock display orientation",
        "description": "Ensures content is not locked to any specific display orientation, and the content is operable in all display orientations"
      }
    },
    {
      "id": "definition-list",
      "selector": "dl",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "structured-dlitems",
        "only-dlitems"
      ],
      "tags": [
        "cat.structure",
        "wcag2a",
        "wcag131"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return !node.getAttribute('role');\n      }",
      "metadata": {
        "help": "<dl> elements must only directly contain properly-ordered <dt> and <dd> groups, <script> or <template> elements",
        "description": "Ensures <dl> elements are structured correctly",
        "mapping": {
          "ruleId": "SC411VAL",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Ensures that all <dl> elements are structured correctly"
        }
      }
    },
    {
      "id": "dlitem",
      "selector": "dd, dt",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "dlitem"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.structure",
        "wcag2a",
        "wcag131"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return !node.getAttribute('role');\n      }",
      "metadata": {
        "help": "<dt> and <dd> elements must be contained by a <dl>",
        "description": "Ensures <dt> and <dd> elements are contained by a <dl>",
        "mapping": {
          "ruleId": "SC411VAL",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Ensures that all <dd> and <dt> elements have a <dl> as a parent"
        }
      }
    },
    {
      "id": "document-title",
      "selector": "html",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "doc-has-title"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag242"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return node.ownerDocument.defaultView.self === node.ownerDocument.defaultView.top;\n      }",
      "metadata": {
        "help": "Documents must have <title> element to aid in navigation",
        "description": "Ensures each HTML document contains a non-empty <title> element",
        "mapping": {
          "ruleId": "130201-C",
          "SC": "2.4.2",
          "weight": 0,
          "description": "Supply a valid title element for this document that is non-empty and useful."
        }
      }
    },
    {
      "id": "duplicate-id-active",
      "selector": "[id]",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "duplicate-id-active"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.parsing",
        "wcag2a",
        "wcag411"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var _axe$commons2 = axe.commons, dom = _axe$commons2.dom, aria = _axe$commons2.aria;\n        var id = node.getAttribute('id').trim();\n        var idSelector = '*[id=\"'.concat(axe.utils.escapeSelector(id), '\"]');\n        var idMatchingElms = Array.from(dom.getRootNode(node).querySelectorAll(idSelector));\n        return !aria.isAccessibleRef(node) && idMatchingElms.some(dom.isFocusable);\n      }",
      "metadata": {
        "help": "IDs of active elements must be unique",
        "description": "Ensures every id attribute value of active elements is unique"
      }
    },
    {
      "id": "duplicate-id-aria",
      "selector": "[id]",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "duplicate-id-aria"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.parsing",
        "wcag2a",
        "wcag411"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return axe.commons.aria.isAccessibleRef(node);\n      }",
      "metadata": {
        "help": "IDs used in ARIA and labels must be unique",
        "description": "Ensures every id attribute value used in ARIA and in labels is unique"
      }
    },
    {
      "id": "duplicate-id",
      "selector": "[id]",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "duplicate-id"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.parsing",
        "wcag2a",
        "wcag411"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var _axe$commons3 = axe.commons, dom = _axe$commons3.dom, aria = _axe$commons3.aria;\n        var id = node.getAttribute('id').trim();\n        var idSelector = '*[id=\"'.concat(axe.utils.escapeSelector(id), '\"]');\n        var idMatchingElms = Array.from(dom.getRootNode(node).querySelectorAll(idSelector));\n        return !aria.isAccessibleRef(node) && idMatchingElms.every(function(elm) {\n          return !dom.isFocusable(elm);\n        });\n      }",
      "metadata": {
        "help": "id attribute value must be unique",
        "description": "Ensures every id attribute value is unique",
        "mapping": {
          "ruleId": "SC411NID",
          "SC": "4.1.1",
          "weight": 0,
          "description": "Ensures that each element on the page with an ID attribute has a unique ID attribute value"
        }
      }
    },
    {
      "id": "empty-heading",
      "selector": "h1, h2, h3, h4, h5, h6, [role=\"heading\"]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "has-visible-text"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var explicitRoles;\n        if (node.hasAttribute('role')) {\n          explicitRoles = node.getAttribute('role').split(/\\s+/i).filter(axe.commons.aria.isValidRole);\n        }\n        if (explicitRoles && explicitRoles.length > 0) {\n          return explicitRoles.includes('heading');\n        } else {\n          return axe.commons.aria.implicitRole(node) === 'heading';\n        }\n      }",
      "metadata": {
        "help": "Headings must not be empty",
        "description": "Ensures headings have discernible text"
      }
    },
    {
      "id": "focus-order-semantics",
      "selector": "div, h1, h2, h3, h4, h5, h6, [role=heading], p, span",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        {
          "options": [],
          "id": "has-widget-role"
        },
        {
          "options": [],
          "id": "valid-scrollable-semantics"
        }
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return axe.commons.dom.insertedIntoFocusOrder(node);\n      }",
      "metadata": {
        "help": "Elements in the focus order need a role appropriate for interactive content",
        "description": "Ensures elements in the focus order have an appropriate role"
      }
    },
    {
      "id": "form-field-multiple-labels",
      "selector": "input, select, textarea",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "multiple-label"
      ],
      "tags": [
        "cat.forms",
        "wcag2a",
        "wcag332"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        if (node.nodeName.toLowerCase() !== 'input' || node.hasAttribute('type') === false) {\n          return true;\n        }\n        var type = node.getAttribute('type').toLowerCase();\n        return [ 'hidden', 'image', 'button', 'submit', 'reset' ].includes(type) === false;\n      }",
      "metadata": {
        "help": "Form field should not have multiple label elements",
        "description": "Ensures form field does not have multiple label elements"
      }
    },
    {
      "id": "frame-tested",
      "selector": "frame, iframe",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [
        {
          "options": {
            "isViolation": false
          },
          "id": "frame-tested"
        }
      ],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Frames must be tested with axe-core",
        "description": "Ensures <iframe> and <frame> elements contain the axe-core script"
      }
    },
    {
      "id": "frame-title-unique",
      "selector": "frame[title], iframe[title]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "unique-frame-title"
      ],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var title = node.getAttribute('title');\n        return !!(title ? axe.commons.text.sanitize(title).trim() : '');\n      }",
      "metadata": {
        "help": "Frames must have a unique title attribute",
        "description": "Ensures <iframe> and <frame> elements contain a unique title attribute"
      }
    },
    {
      "id": "frame-title",
      "selector": "frame, iframe",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-label",
        "aria-labelledby",
        "non-empty-title",
        "role-presentation",
        "role-none"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag241",
        "wcag412",
        "section508",
        "section508.22.i"
      ],
      "preload": false,
      "metadata": {
        "help": "Frames must have title attribute",
        "description": "Ensures <iframe> and <frame> elements contain a non-empty title attribute",
        "mapping": {
          "ruleId": "120101-A",
          "SC": "4.1.2",
          "weight": 2,
          "description": "Ensure that all iframe and frame elements contain a unique and non-empty title attribute"
        }
      }
    },
    {
      "id": "heading-order",
      "selector": "h1, h2, h3, h4, h5, h6, [role=heading]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "heading-order"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var explicitRoles;\n        if (node.hasAttribute('role')) {\n          explicitRoles = node.getAttribute('role').split(/\\s+/i).filter(axe.commons.aria.isValidRole);\n        }\n        if (explicitRoles && explicitRoles.length > 0) {\n          return explicitRoles.includes('heading');\n        } else {\n          return axe.commons.aria.implicitRole(node) === 'heading';\n        }\n      }",
      "metadata": {
        "help": "Heading levels should only increase by one",
        "description": "Ensures the order of headings is semantically correct",
        "mapping": {
          "ruleId": "N030501-A",
          "SC": "1.3.1",
          "weight": 3,
          "description": "Ensure that the order in which the headings appear in the DOM is semantically correct"
        }
      }
    },
    {
      "id": "hidden-content",
      "selector": "*",
      "excludeHidden": false,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "hidden-content"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Hidden content on the page cannot be analyzed",
        "description": "Informs users about hidden content."
      }
    },
    {
      "id": "html-has-lang",
      "selector": "html",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "has-lang"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.language",
        "wcag2a",
        "wcag311"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return node.ownerDocument.defaultView.self === node.ownerDocument.defaultView.top;\n      }",
      "metadata": {
        "help": "<html> element must have a lang attribute",
        "description": "Ensures every HTML document has a lang attribute"
      }
    },
    {
      "id": "html-lang-valid",
      "selector": "html[lang], html[xml\\:lang]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "valid-lang"
      ],
      "tags": [
        "cat.language",
        "wcag2a",
        "wcag311"
      ],
      "preload": false,
      "metadata": {
        "help": "<html> element must have a valid value for the lang attribute",
        "description": "Ensures the lang attribute of the <html> element has a valid value"
      }
    },
    {
      "id": "html-xml-lang-mismatch",
      "selector": "html[lang][xml\\:lang]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        "xml-lang-mismatch"
      ],
      "none": [],
      "tags": [
        "cat.language",
        "wcag2a",
        "wcag311"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var getBaseLang = axe.utils.getBaseLang;\n        var primaryLangValue = getBaseLang(node.getAttribute('lang'));\n        var primaryXmlLangValue = getBaseLang(node.getAttribute('xml:lang'));\n        return axe.utils.validLangs().includes(primaryLangValue) && axe.utils.validLangs().includes(primaryXmlLangValue);\n      }",
      "metadata": {
        "help": "HTML elements with lang and xml:lang must have the same base language",
        "description": "Ensure that HTML elements with both valid lang and xml:lang attributes agree on the base language of the page"
      }
    },
    {
      "id": "identical-links-same-purpose",
      "selector": "a[href], area[href], [role=\"link\"]",
      "excludeHidden": false,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [
        "identical-links-same-purpose"
      ],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var _axe$commons4 = axe.commons, aria = _axe$commons4.aria, text = _axe$commons4.text;\n        var hasAccName = !!text.accessibleTextVirtual(virtualNode);\n        if (!hasAccName) {\n          return false;\n        }\n        var role = aria.getRole(node);\n        if (role && role !== 'link') {\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "help": "Links with the same name have a similar purpose",
        "description": "Ensure that links with the same accessible name serve a similar purpose"
      }
    },
    {
      "id": "image-alt",
      "selector": "img",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "has-alt",
        "aria-label",
        "aria-labelledby",
        "non-empty-title",
        "role-presentation",
        "role-none"
      ],
      "all": [],
      "none": [
        "alt-space-value"
      ],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag111",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "Images must have alternate text",
        "description": "Ensures <img> elements have alternate text or a role of none or presentation",
        "mapping": {
          "ruleId": "IMG_NO_ALT",
          "SC": "1.1.1",
          "weight": 0,
          "description": "Ensures that every <img> element has an alternative text or is marked as presentational"
        }
      }
    },
    {
      "id": "image-redundant-alt",
      "selector": "img",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "duplicate-img-label"
      ],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Alternative text of images should not be repeated as text",
        "description": "Ensure image alternative is not repeated as text"
      }
    },
    {
      "id": "input-button-name",
      "selector": "input[type=\"button\"], input[type=\"submit\"], input[type=\"reset\"]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "non-empty-if-present",
        "non-empty-value",
        "aria-label",
        "aria-labelledby",
        "role-presentation",
        "role-none",
        "non-empty-title"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.name-role-value",
        "wcag2a",
        "wcag412",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "Input buttons must have discernible text",
        "description": "Ensures input buttons have discernible text"
      }
    },
    {
      "id": "input-image-alt",
      "selector": "input[type=\"image\"]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "non-empty-alt",
        "aria-label",
        "aria-labelledby",
        "non-empty-title"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag111",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "Image buttons must have alternate text",
        "description": "Ensures <input type=\"image\"> elements have alternate text",
        "mapping": {
          "ruleId": "010103-A",
          "SC": "1.1.1",
          "weight": 0,
          "description": "Ensures that every <input> that represents an image button has an accessible name"
        }
      }
    },
    {
      "id": "label-content-name-mismatch",
      "selector": "*",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "pixelThreshold": 0.1,
            "occuranceThreshold": 3
          },
          "id": "label-content-name-mismatch"
        }
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var _axe$commons5 = axe.commons, aria = _axe$commons5.aria, text = _axe$commons5.text;\n        var role = aria.getRole(node);\n        if (!role) {\n          return false;\n        }\n        var widgetRoles = Object.keys(aria.lookupTable.role).filter(function(key) {\n          return aria.lookupTable.role[key].type === 'widget';\n        });\n        var isWidgetType = widgetRoles.includes(role);\n        if (!isWidgetType) {\n          return false;\n        }\n        var rolesWithNameFromContents = aria.getRolesWithNameFromContents();\n        if (!rolesWithNameFromContents.includes(role)) {\n          return false;\n        }\n        if (!text.sanitize(aria.arialabelText(virtualNode)) && !text.sanitize(aria.arialabelledbyText(node))) {\n          return false;\n        }\n        if (!text.sanitize(text.visibleVirtual(virtualNode))) {\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "help": "Elements must have their visible text as part of their accessible name",
        "description": "Ensures that elements labelled through their content must have their visible text as part of their accessible name"
      }
    },
    {
      "id": "label-title-only",
      "selector": "input, select, textarea",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "title-only"
      ],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        if (node.nodeName.toLowerCase() !== 'input' || node.hasAttribute('type') === false) {\n          return true;\n        }\n        var type = node.getAttribute('type').toLowerCase();\n        return [ 'hidden', 'image', 'button', 'submit', 'reset' ].includes(type) === false;\n      }",
      "metadata": {
        "help": "Form elements should have a visible label",
        "description": "Ensures that every form element is not solely labeled using the title or aria-describedby attributes",
        "mapping": {
          "ruleId": "120401-E",
          "SC": "1.3.1",
          "weight": 2,
          "description": "Ensures that every <input> that requires a label is not only labeled using the title attribute"
        }
      }
    },
    {
      "id": "label",
      "selector": "input, select, textarea",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-label",
        "aria-labelledby",
        "implicit-label",
        "explicit-label",
        "non-empty-title"
      ],
      "all": [],
      "none": [
        "help-same-as-label",
        "hidden-explicit-label"
      ],
      "tags": [
        "cat.forms",
        "wcag2a",
        "wcag332",
        "wcag131",
        "section508",
        "section508.22.n"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        if (node.nodeName.toLowerCase() !== 'input' || node.hasAttribute('type') === false) {\n          return true;\n        }\n        var type = node.getAttribute('type').toLowerCase();\n        return [ 'hidden', 'image', 'button', 'submit', 'reset' ].includes(type) === false;\n      }",
      "metadata": {
        "help": "Form elements must have labels",
        "description": "Ensures every form element has a label",
        "mapping": {
          "ruleId": "120401-E",
          "SC": "1.3.1",
          "weight": 0,
          "description": "Ensures that every input element that requires a label, has an appropriate label"
        }
      }
    },
    {
      "id": "landmark-banner-is-top-level",
      "selector": "header:not([role]), [role=banner]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "landmark-is-top-level"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var nativeScopeFilter = 'article, aside, main, nav, section';\n        return node.hasAttribute('role') || !axe.commons.dom.findUpVirtual(virtualNode, nativeScopeFilter);\n      }",
      "metadata": {
        "help": "Banner landmark must not be contained in another landmark",
        "description": "Ensures the banner landmark is at top level"
      }
    },
    {
      "id": "landmark-complementary-is-top-level",
      "selector": "aside:not([role]), [role=complementary]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "landmark-is-top-level"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Aside must not be contained in another landmark",
        "description": "Ensures the complementary landmark or aside is at top level"
      }
    },
    {
      "id": "landmark-contentinfo-is-top-level",
      "selector": "footer:not([role]), [role=contentinfo]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "landmark-is-top-level"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var nativeScopeFilter = 'article, aside, main, nav, section';\n        return node.hasAttribute('role') || !axe.commons.dom.findUpVirtual(virtualNode, nativeScopeFilter);\n      }",
      "metadata": {
        "help": "Contentinfo landmark must not be contained in another landmark",
        "description": "Ensures the contentinfo landmark is at top level"
      }
    },
    {
      "id": "landmark-main-is-top-level",
      "selector": "main:not([role]), [role=main]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "landmark-is-top-level"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Main landmark must not be contained in another landmark",
        "description": "Ensures the main landmark is at top level"
      }
    },
    {
      "id": "landmark-no-duplicate-banner",
      "selector": "header:not([role]), [role=banner]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "selector": "header:not([role]), [role=banner]",
            "nativeScopeFilter": "article, aside, main, nav, section"
          },
          "id": "page-no-duplicate-banner"
        }
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Document must not have more than one banner landmark",
        "description": "Ensures the document has at most one banner landmark"
      }
    },
    {
      "id": "landmark-no-duplicate-contentinfo",
      "selector": "footer:not([role]), [role=contentinfo]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "selector": "footer:not([role]), [role=contentinfo]",
            "nativeScopeFilter": "article, aside, main, nav, section"
          },
          "id": "page-no-duplicate-contentinfo"
        }
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Document must not have more than one contentinfo landmark",
        "description": "Ensures the document has at most one contentinfo landmark"
      }
    },
    {
      "id": "landmark-no-duplicate-main",
      "selector": "main:not([role]), [role=main]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "selector": "main:not([role]), [role='main']"
          },
          "id": "page-no-duplicate-main"
        }
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Document must not have more than one main landmark",
        "description": "Ensures the document has at most one main landmark"
      }
    },
    {
      "id": "landmark-one-main",
      "selector": "html",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [
        {
          "options": {
            "selector": "main:not([role]), [role='main']"
          },
          "id": "page-has-main"
        }
      ],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Document must have one main landmark",
        "description": "Ensures the document has a main landmark"
      }
    },
    {
      "id": "landmark-unique",
      "selector": "[role=banner], [role=complementary], [role=contentinfo], [role=main], [role=navigation], [role=region], [role=search], [role=form], form, footer, header, aside, main, nav, section",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "landmark-is-unique"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var excludedParentsForHeaderFooterLandmarks = [ 'article', 'aside', 'main', 'nav', 'section' ].join(',');\n        function isHeaderFooterLandmark(headerFooterElement) {\n          return !axe.commons.dom.findUpVirtual(headerFooterElement, excludedParentsForHeaderFooterLandmarks);\n        }\n        function isLandmarkVirtual(virtualNode) {\n          var actualNode = virtualNode.actualNode;\n          var landmarkRoles = axe.commons.aria.getRolesByType('landmark');\n          var role = axe.commons.aria.getRole(actualNode);\n          if (!role) {\n            return false;\n          }\n          var nodeName = actualNode.nodeName.toUpperCase();\n          if (nodeName === 'HEADER' || nodeName === 'FOOTER') {\n            return isHeaderFooterLandmark(virtualNode);\n          }\n          if (nodeName === 'SECTION' || nodeName === 'FORM') {\n            var accessibleText = axe.commons.text.accessibleTextVirtual(virtualNode);\n            return !!accessibleText;\n          }\n          return landmarkRoles.indexOf(role) >= 0 || role === 'region';\n        }\n        return isLandmarkVirtual(virtualNode) && axe.commons.dom.isVisible(node, true);\n      }",
      "metadata": {
        "help": "Ensures landmarks are unique",
        "description": "Landmarks must have a unique role or role/label/title (i.e. accessible name) combination"
      }
    },
    {
      "id": "layout-table",
      "selector": "table",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "has-th",
        "has-caption",
        "has-summary"
      ],
      "tags": [
        "cat.semantics",
        "wcag2a",
        "wcag131",
        "deprecated"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var role = (node.getAttribute('role') || '').toLowerCase();\n        return !((role === 'presentation' || role === 'none') && !axe.commons.dom.isFocusable(node)) && !axe.commons.table.isDataTable(node);\n      }",
      "metadata": {
        "help": "Layout tables must not use data table elements",
        "description": "Ensures presentational <table> elements do not use <th>, <caption> elements or the summary attribute",
        "mapping": {
          "ruleId": "050401-A",
          "SC": "1.3.1",
          "weight": 1,
          "description": "Ensures that <table> elements that are being used for layout do not contain markup only relevant for data tables"
        }
      }
    },
    {
      "id": "link-in-text-block",
      "selector": "a[href], [role=link]",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        "link-in-text-block"
      ],
      "none": [],
      "tags": [
        "cat.color",
        "experimental",
        "wcag2a",
        "wcag141"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var text = axe.commons.text.sanitize(node.textContent);\n        var role = node.getAttribute('role');\n        if (role && role !== 'link') {\n          return false;\n        }\n        if (!text) {\n          return false;\n        }\n        if (!axe.commons.dom.isVisible(node, false)) {\n          return false;\n        }\n        return axe.commons.dom.isInTextBlock(node);\n      }",
      "metadata": {
        "help": "Links must be distinguished from surrounding text in a way that does not rely on color",
        "description": "Links can be distinguished without relying on color"
      }
    },
    {
      "id": "link-name",
      "selector": "a[href]:not([role=button]), [role=link]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "has-visible-text",
        "aria-label",
        "aria-labelledby",
        "role-presentation",
        "role-none"
      ],
      "all": [],
      "none": [
        "focusable-no-name"
      ],
      "tags": [
        "cat.name-role-value",
        "wcag2a",
        "wcag412",
        "wcag244",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "Links must have discernible text",
        "description": "Ensures links have discernible text",
        "mapping": {
          "ruleId": "SC412LNKN",
          "SC": "4.1.2",
          "weight": 1,
          "description": "Ensures that every link has an accessible name"
        }
      }
    },
    {
      "id": "list",
      "selector": "ul, ol",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "only-listitems"
      ],
      "tags": [
        "cat.structure",
        "wcag2a",
        "wcag131"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return !node.getAttribute('role');\n      }",
      "metadata": {
        "help": "<ul> and <ol> must only directly contain <li>, <script> or <template> elements",
        "description": "Ensures that lists are structured correctly",
        "mapping": {
          "ruleId": "030601-C",
          "SC": "1.3.1",
          "weight": 1,
          "description": "Ensures that lists are structured correctly"
        }
      }
    },
    {
      "id": "listitem",
      "selector": "li",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "listitem"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.structure",
        "wcag2a",
        "wcag131"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return !node.getAttribute('role');\n      }",
      "metadata": {
        "help": "<li> elements must be contained in a <ul> or <ol>",
        "description": "Ensures <li> elements are used semantically",
        "mapping": {
          "ruleId": "030601-A",
          "SC": "1.3.1",
          "weight": 1,
          "description": "Ensures that every list item is used semantically"
        }
      }
    },
    {
      "id": "marquee",
      "selector": "marquee",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "is-on-screen"
      ],
      "tags": [
        "cat.parsing",
        "wcag2a",
        "wcag222"
      ],
      "preload": false,
      "metadata": {
        "help": "<marquee> elements are deprecated and must not be used",
        "description": "Ensures <marquee> elements are not used",
        "mapping": {
          "ruleId": "070301-A",
          "SC": "2.2.2",
          "weight": 0,
          "description": "Ensures that the deprecated <marquee> tag is not used"
        }
      }
    },
    {
      "id": "meta-refresh",
      "selector": "meta[http-equiv=\"refresh\"]",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "meta-refresh"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.time-and-media",
        "wcag2a",
        "wcag2aaa",
        "wcag221",
        "wcag224",
        "wcag325"
      ],
      "preload": false,
      "metadata": {
        "help": "Timed refresh must not exist",
        "description": "Ensures <meta http-equiv=\"refresh\"> is not used",
        "mapping": {
          "ruleId": "070401-A",
          "SC": "2.2.4",
          "weight": 1,
          "description": "Ensures that <meta> refresh is not used"
        }
      }
    },
    {
      "id": "meta-viewport-large",
      "selector": "meta[name=\"viewport\"]",
      "excludeHidden": false,
      "enabled": false,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "scaleMinimum": 5,
            "lowerBound": 2
          },
          "id": "meta-viewport-large"
        }
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Users should be able to zoom and scale the text up to 500%",
        "description": "Ensures <meta name=\"viewport\"> can scale a significant amount",
        "mapping": {}
      }
    },
    {
      "id": "meta-viewport",
      "selector": "meta[name=\"viewport\"]",
      "excludeHidden": false,
      "enabled": false,
      "pageLevel": false,
      "any": [
        {
          "options": {
            "scaleMinimum": 2
          },
          "id": "meta-viewport"
        }
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Zooming and scaling must not be disabled",
        "description": "Ensures <meta name=\"viewport\"> does not disable text scaling and zooming",
        "mapping": {}
      }
    },
    {
      "id": "no-autoplay-audio",
      "selector": "audio[autoplay], video[autoplay]",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        {
          "options": {
            "allowedDuration": 3
          },
          "id": "no-autoplay-audio"
        }
      ],
      "none": [],
      "tags": [
        "wcag2a",
        "wcag142",
        "experimental"
      ],
      "preload": true,
      "matches": "function matches(node, virtualNode, context) {\n        if (!node.currentSrc) {\n          return false;\n        }\n        if (node.hasAttribute('paused') || node.hasAttribute('muted')) {\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "help": "<video> or <audio> elements do not autoplay audio",
        "description": "Ensures <video> or <audio> elements do not autoplay audio for more than 3 seconds without a control mechanism to stop or mute the audio"
      }
    },
    {
      "id": "object-alt",
      "selector": "object",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "has-visible-text",
        "aria-label",
        "aria-labelledby",
        "non-empty-title",
        "role-presentation",
        "role-none"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag111",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "<object> elements must have alternate text",
        "description": "Ensures <object> elements have alternate text",
        "mapping": {
          "ruleId": "010105-A",
          "SC": "1.1.1",
          "weight": 0,
          "description": "Ensures that every <object> element has a text alternative"
        }
      }
    },
    {
      "id": "p-as-heading",
      "selector": "p",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        {
          "options": {
            "margins": [
              {
                "weight": 150,
                "italic": true
              },
              {
                "weight": 150,
                "size": 1.15
              },
              {
                "italic": true,
                "size": 1.15
              },
              {
                "size": 1.4
              }
            ]
          },
          "id": "p-as-heading"
        }
      ],
      "none": [],
      "tags": [
        "cat.semantics",
        "wcag2a",
        "wcag131",
        "experimental"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var children = Array.from(node.parentNode.childNodes);\n        var nodeText = node.textContent.trim();\n        var isSentence = /[.!?:;](?![.!?:;])/g;\n        if (nodeText.length === 0 || (nodeText.match(isSentence) || []).length >= 2) {\n          return false;\n        }\n        var siblingsAfter = children.slice(children.indexOf(node) + 1).filter(function(elm) {\n          return elm.nodeName.toUpperCase() === 'P' && elm.textContent.trim() !== '';\n        });\n        return siblingsAfter.length !== 0;\n      }",
      "metadata": {
        "help": "Bold, italic text and font-size are not used to style p elements as a heading",
        "description": "Ensure p elements are not used to style headings"
      }
    },
    {
      "id": "page-has-heading-one",
      "selector": "html",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [
        {
          "options": {
            "selector": "h1:not([role]), [role=\"heading\"][aria-level=\"1\"]"
          },
          "id": "page-has-heading-one"
        }
      ],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Page must contain a level-one heading",
        "description": "Ensure that the page, or at least one of its frames contains a level-one heading"
      }
    },
    {
      "id": "radiogroup",
      "selector": "input[type=radio][name]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "group-labelledby",
        "fieldset"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Radio inputs with the same name attribute value must be part of a group",
        "description": "Ensures related <input type=\"radio\"> elements have a group and that the group designation is consistent",
        "mapping": {
          "ruleId": "SC131GROUP",
          "SC": "1.3.1",
          "weight": 3,
          "description": "Ensures that radio button groups are part of a group structure"
        }
      }
    },
    {
      "id": "region",
      "selector": "body *",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "region"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "All page content must be contained by landmarks",
        "description": "Ensures all page content is contained by landmarks",
        "mapping": {
          "SC": "2.4.1",
          "weight": 2,
          "description": "Ensures that all content on a page is contained within a landmark region"
        }
      }
    },
    {
      "id": "role-img-alt",
      "selector": "[role='img']:not(img):not(area):not(input):not(object)",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "aria-label",
        "aria-labelledby",
        "non-empty-title"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag111",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return node.namespaceURI === 'http://www.w3.org/1999/xhtml';\n      }",
      "metadata": {
        "help": "[role='img'] elements have an alternative text",
        "description": "Ensures [role='img'] elements have alternate text"
      }
    },
    {
      "id": "scope-attr-valid",
      "selector": "td[scope], th[scope]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [
        "html5-scope",
        "scope-value"
      ],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "scope attribute should be used correctly",
        "description": "Ensures the scope attribute is used correctly on tables",
        "mapping": {
          "ruleId": "050102-D",
          "SC": "1.3.1",
          "weight": 1,
          "description": "Ensures that the scope attribute is used correctly on tables"
        }
      }
    },
    {
      "id": "scrollable-region-focusable",
      "selector": "*",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "focusable-content",
        "focusable-element"
      ],
      "all": [],
      "none": [],
      "tags": [
        "wcag2a",
        "wcag211"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        var querySelectorAll = axe.utils.querySelectorAll;\n        var hasContentVirtual = axe.commons.dom.hasContentVirtual;\n        if (!!axe.utils.getScroll(node, 13) === false) {\n          return false;\n        }\n        var nodeAndDescendents = querySelectorAll(virtualNode, '*');\n        var hasVisibleChildren = nodeAndDescendents.some(function(elm) {\n          return hasContentVirtual(elm, true, true);\n        });\n        if (!hasVisibleChildren) {\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "help": "Ensure that scrollable region has keyboard access",
        "description": "Elements that have scrollable content should be accessible by keyboard"
      }
    },
    {
      "id": "server-side-image-map",
      "selector": "img[ismap]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "exists"
      ],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag211",
        "section508",
        "section508.22.f"
      ],
      "preload": false,
      "metadata": {
        "help": "Server-side image maps must not be used",
        "description": "Ensures that server-side image maps are not used",
        "mapping": {
          "ruleId": "090101-A",
          "SC": "2.1.1",
          "weight": 0,
          "description": "Ensures that server-side image maps are never used"
        }
      }
    },
    {
      "id": "skip-link",
      "selector": "a[href^=\"#\"], a[href^=\"/#\"]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "skip-link"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return axe.commons.dom.isSkipLink(node) && axe.commons.dom.isOffscreen(node);\n      }",
      "metadata": {
        "help": "The skip-link target should exist and be focusable",
        "description": "Ensure all skip links have a focusable target",
        "mapping": {
          "ruleId": "SC241SKP",
          "SC": "2.4.1",
          "weight": 2,
          "description": "There is no mechanism to skip to the main content of the page"
        }
      }
    },
    {
      "id": "svg-img-alt",
      "selector": "[role=\"img\"], [role=\"graphics-symbol\"], svg[role=\"graphics-document\"]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [
        "svg-non-empty-title",
        "aria-label",
        "aria-labelledby",
        "non-empty-title"
      ],
      "all": [],
      "none": [],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag111",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return node.namespaceURI === 'http://www.w3.org/2000/svg';\n      }",
      "metadata": {
        "help": "svg elements with an img role have an alternative text",
        "description": "Ensures svg elements with an img, graphics-document or graphics-symbol role have an accessible text"
      }
    },
    {
      "id": "tabindex",
      "selector": "[tabindex]",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [
        "tabindex"
      ],
      "all": [],
      "none": [],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "Elements should not have tabindex greater than zero",
        "description": "Ensures tabindex attribute values are not greater than 0",
        "mapping": {}
      }
    },
    {
      "id": "table-duplicate-name",
      "selector": "table",
      "excludeHidden": true,
      "enabled": false,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "same-caption-summary"
      ],
      "tags": [],
      "preload": false,
      "metadata": {
        "help": "The <caption> element should not contain the same text as the summary attribute",
        "description": "Ensure that tables do not have the same summary and caption",
        "mapping": {}
      }
    },
    {
      "id": "table-fake-caption",
      "selector": "table",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        "caption-faked"
      ],
      "none": [],
      "tags": [
        "cat.tables",
        "experimental",
        "wcag2a",
        "wcag131",
        "section508",
        "section508.22.g"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return axe.commons.table.isDataTable(node);\n      }",
      "metadata": {
        "help": "Data or header cells should not be used to give caption to a data table.",
        "description": "Ensure that tables with a caption use the <caption> element.",
        "mapping": {}
      }
    },
    {
      "id": "td-has-header",
      "selector": "table",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        "td-has-header"
      ],
      "none": [],
      "tags": [
        "cat.tables",
        "experimental",
        "wcag2a",
        "wcag131",
        "section508",
        "section508.22.g"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        if (axe.commons.table.isDataTable(node)) {\n          var tableArray = axe.commons.table.toArray(node);\n          return tableArray.length >= 3 && tableArray[0].length >= 3 && tableArray[1].length >= 3 && tableArray[2].length >= 3;\n        }\n        return false;\n      }",
      "metadata": {
        "help": "All non-empty td element in table larger than 3 by 3 must have an associated table header",
        "description": "Ensure that each non-empty data cell in a large table has one or more table headers",
        "mapping": {}
      }
    },
    {
      "id": "td-headers-attr",
      "selector": "table",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        "td-headers-attr"
      ],
      "none": [],
      "tags": [
        "cat.tables",
        "wcag2a",
        "wcag131",
        "section508",
        "section508.22.g"
      ],
      "preload": false,
      "metadata": {
        "help": "All cells in a table element that use the headers attribute must only refer to other cells of that same table",
        "description": "Ensure that each cell in a table using the headers refers to another cell in that table"
      }
    },
    {
      "id": "th-has-data-cells",
      "selector": "table",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [
        "th-has-data-cells"
      ],
      "none": [],
      "tags": [
        "cat.tables",
        "wcag2a",
        "wcag131",
        "section508",
        "section508.22.g"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return axe.commons.table.isDataTable(node);\n      }",
      "metadata": {
        "help": "All th elements and elements with role=columnheader/rowheader must have data cells they describe",
        "description": "Ensure that each table header in a data table refers to data cells",
        "mapping": {}
      }
    },
    {
      "id": "valid-lang",
      "selector": "[lang], [xml\\:lang]",
      "excludeHidden": true,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "valid-lang"
      ],
      "tags": [
        "cat.language",
        "wcag2aa",
        "wcag312"
      ],
      "preload": false,
      "matches": "function matches(node, virtualNode, context) {\n        return node.nodeName.toLowerCase() !== 'html';\n      }",
      "metadata": {
        "help": "lang attribute must have a valid value",
        "description": "Ensures lang attributes have valid values",
        "mapping": {
          "ruleId": "040101-B",
          "SC": "3.1.2",
          "weight": 1,
          "description": "Ensures that when the 'lang' attribute is used, it has a valid value"
        }
      }
    },
    {
      "id": "video-caption",
      "selector": "video",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "caption"
      ],
      "tags": [
        "cat.text-alternatives",
        "wcag2a",
        "wcag122",
        "section508",
        "section508.22.a"
      ],
      "preload": false,
      "metadata": {
        "help": "<video> elements must have captions",
        "description": "Ensures <video> elements have captions",
        "mapping": {
          "ruleId": "010402-D",
          "SC": "1.2.2",
          "weight": 1,
          "description": "Ensures that the HTML5 <video> tag is captioned"
        }
      }
    },
    {
      "id": "video-description",
      "selector": "video",
      "excludeHidden": false,
      "enabled": true,
      "pageLevel": false,
      "any": [],
      "all": [],
      "none": [
        "description"
      ],
      "tags": [
        "cat.text-alternatives",
        "wcag2aa",
        "wcag125",
        "section508",
        "section508.22.b",
        "deprecated"
      ],
      "preload": false,
      "metadata": {
        "help": "<video> elements must have an audio description track",
        "description": "Ensures <video> elements have audio descriptions",
        "mapping": {
          "ruleId": "010301-Q1",
          "SC": "1.2.5",
          "weight": 1,
          "description": "Ensures that every <video> tag has an audio description"
        }
      }
    }
  ],
  "checks": [
    {
      "id": "has-alert-role",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n          var role = node.getAttribute('role');\n          if (role === null) {\n          return false;\n          }\n          var roleType = axe.commons.aria.getRoleType(role);\n          return roleType === 'alert';\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "function anonymous(it) {\n              var out = 'Element has a alert role.';\n              return out;\n            }",
          "fail": "function anonymous(it) {\n              var out = 'Add role=\"alert\" to the ui-alert element';\n              return out;\n            }"
        }
      }
    },
    {
      "id": "accesskeys",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (axe.commons.dom.isVisible(node, false)) {\n          this.data(node.getAttribute('accesskey'));\n          this.relatedNodes([ node ]);\n        }\n        return true;\n      }",
      "after": "function after(results, options) {\n        var seen = {};\n        return results.filter(function(r) {\n          if (!r.data) {\n            return false;\n          }\n          var key = r.data.toUpperCase();\n          if (!seen[key]) {\n            seen[key] = r;\n            r.relatedNodes = [];\n            return true;\n          }\n          seen[key].relatedNodes.push(r.relatedNodes[0]);\n          return false;\n        }).map(function(r) {\n          r.result = !!r.relatedNodes.length;\n          return r;\n        });\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Accesskey attribute value is unique",
          "fail": "Document has multiple elements with the same accesskey"
        }
      }
    },
    {
      "id": "non-empty-alt",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var label = virtualNode.attr('alt');\n        return !!(label ? axe.commons.text.sanitize(label).trim() : '');\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Element has a non-empty alt attribute",
          "fail": "Element has no alt attribute or the alt attribute is empty"
        }
      }
    },
    {
      "id": "non-empty-title",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var text = axe.commons.text;\n        return !!text.sanitize(text.titleText(node));\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Element has a title attribute",
          "fail": "Element has no title attribute or the title attribute is empty"
        }
      }
    },
    {
      "id": "aria-label",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons17 = axe.commons, text = _axe$commons17.text, aria = _axe$commons17.aria;\n        return !!text.sanitize(aria.arialabelText(virtualNode));\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "aria-label attribute exists and is not empty",
          "fail": "aria-label attribute does not exist or is empty"
        }
      }
    },
    {
      "id": "aria-labelledby",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons18 = axe.commons, text = _axe$commons18.text, aria = _axe$commons18.aria;\n        return !!text.sanitize(aria.arialabelledbyText(node));\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "aria-labelledby attribute exists and references elements that are visible to screen readers",
          "fail": "aria-labelledby attribute does not exist, references elements that do not exist or references elements that are empty"
        }
      }
    },
    {
      "id": "aria-allowed-attr",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var invalid = [];\n        var attr, attrName, allowed, role = node.getAttribute('role'), attrs = axe.utils.getNodeAttributes(node);\n        if (!role) {\n          role = axe.commons.aria.implicitRole(node);\n        }\n        allowed = axe.commons.aria.allowedAttr(role);\n        if (Array.isArray(options[role])) {\n          allowed = axe.utils.uniqueArray(options[role].concat(allowed));\n        }\n        if (role && allowed) {\n          for (var i = 0, l = attrs.length; i < l; i++) {\n            attr = attrs[i];\n            attrName = attr.name;\n            if (axe.commons.aria.validateAttr(attrName) && !allowed.includes(attrName)) {\n              invalid.push(attrName + '=\"' + attr.nodeValue + '\"');\n            }\n          }\n        }\n        if (invalid.length) {\n          this.data(invalid);\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "ARIA attributes are used correctly for the defined role",
          "fail": {
            "singular": "ARIA attribute is not allowed: ${data.values}",
            "plural": "ARIA attributes are not allowed: ${data.values}"
          }
        }
      }
    },
    {
      "id": "aria-unsupported-attr",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var nodeName = node.nodeName.toUpperCase();\n        var lookupTable = axe.commons.aria.lookupTable;\n        var role = axe.commons.aria.getRole(node);\n        var unsupportedAttrs = Array.from(axe.utils.getNodeAttributes(node)).filter(function(_ref2) {\n          var name = _ref2.name;\n          var attribute = lookupTable.attributes[name];\n          if (!axe.commons.aria.validateAttr(name)) {\n            return false;\n          }\n          var unsupported = attribute.unsupported;\n          if (_typeof(unsupported) !== 'object') {\n            return !!unsupported;\n          }\n          var isException = axe.commons.matches(node, unsupported.exceptions);\n          if (!Object.keys(lookupTable.evaluateRoleForElement).includes(nodeName)) {\n            return !isException;\n          }\n          return !lookupTable.evaluateRoleForElement[nodeName]({\n            node: node,\n            role: role,\n            out: isException\n          });\n        }).map(function(candidate) {\n          return candidate.name.toString();\n        });\n        if (unsupportedAttrs.length) {\n          this.data(unsupportedAttrs);\n          return true;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "ARIA attribute is supported",
          "fail": "ARIA attribute is not widely supported in screen readers and assistive technologies: ${data.values}"
        }
      }
    },
    {
      "id": "aria-allowed-role",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var dom = axe.commons.dom;\n        var _ref = options || {}, _ref$allowImplicit = _ref.allowImplicit, allowImplicit = _ref$allowImplicit === void 0 ? true : _ref$allowImplicit, _ref$ignoredTags = _ref.ignoredTags, ignoredTags = _ref$ignoredTags === void 0 ? [] : _ref$ignoredTags;\n        var tagName = node.nodeName.toUpperCase();\n        if (ignoredTags.map(function(t) {\n          return t.toUpperCase();\n        }).includes(tagName)) {\n          return true;\n        }\n        var unallowedRoles = axe.commons.aria.getElementUnallowedRoles(node, allowImplicit);\n        if (unallowedRoles.length) {\n          this.data(unallowedRoles);\n          if (!dom.isVisible(node, true)) {\n            return undefined;\n          }\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "ARIA role is allowed for given element",
          "fail": {
            "singular": "ARIA role ${data.values} is not allowed for given element",
            "plural": "ARIA roles ${data.values} are not allowed for given element"
          },
          "incomplete": {
            "singular": "ARIA role ${data.values} must be removed when the element is made visible, as it is not allowed for the element",
            "plural": "ARIA roles ${data.values} must be removed when the element is made visible, as they are not allowed for the element"
          }
        }
      }
    },
    {
      "id": "implicit-role-fallback",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var role = node.getAttribute('role');\n        if (role === null || !axe.commons.aria.isValidRole(role)) {\n          return true;\n        }\n        var roleType = axe.commons.aria.getRoleType(role);\n        return axe.commons.aria.implicitRole(node) === roleType;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Element’s implicit ARIA role is an appropriate fallback",
          "fail": "Element’s implicit ARIA role is not a good fallback for the (unsupported) role"
        }
      }
    },
    {
      "id": "aria-hidden-body",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return node.getAttribute('aria-hidden') !== 'true';\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "No aria-hidden attribute is present on document body",
          "fail": "aria-hidden=true should not be present on the document body"
        }
      }
    },
    {
      "id": "focusable-modal-open",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tabbableElements = virtualNode.tabbableElements.map(function(_ref4) {\n          var actualNode = _ref4.actualNode;\n          return actualNode;\n        });\n        if (!tabbableElements || !tabbableElements.length) {\n          return true;\n        }\n        if (axe.commons.dom.isModalOpen()) {\n          this.relatedNodes(tabbableElements);\n          return undefined;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "No focusable elements while a modal is open",
          "incomplete": "Check that focusable elements are not tabbable in the current state"
        }
      }
    },
    {
      "id": "focusable-disabled",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var elementsThatCanBeDisabled = [ 'BUTTON', 'FIELDSET', 'INPUT', 'SELECT', 'TEXTAREA' ];\n        var tabbableElements = virtualNode.tabbableElements;\n        if (!tabbableElements || !tabbableElements.length) {\n          return true;\n        }\n        var relatedNodes = tabbableElements.reduce(function(out, _ref3) {\n          var el = _ref3.actualNode;\n          var nodeName = el.nodeName.toUpperCase();\n          if (elementsThatCanBeDisabled.includes(nodeName)) {\n            out.push(el);\n          }\n          return out;\n        }, []);\n        this.relatedNodes(relatedNodes);\n        if (relatedNodes.length && axe.commons.dom.isModalOpen()) {\n          return true;\n        }\n        return relatedNodes.length === 0;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "No focusable elements contained within element",
          "fail": "Focusable content should be disabled or be removed from the DOM"
        }
      }
    },
    {
      "id": "focusable-not-tabbable",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var elementsThatCanBeDisabled = [ 'BUTTON', 'FIELDSET', 'INPUT', 'SELECT', 'TEXTAREA' ];\n        var tabbableElements = virtualNode.tabbableElements;\n        if (!tabbableElements || !tabbableElements.length) {\n          return true;\n        }\n        var relatedNodes = tabbableElements.reduce(function(out, _ref5) {\n          var el = _ref5.actualNode;\n          var nodeName = el.nodeName.toUpperCase();\n          if (!elementsThatCanBeDisabled.includes(nodeName)) {\n            out.push(el);\n          }\n          return out;\n        }, []);\n        this.relatedNodes(relatedNodes);\n        if (relatedNodes.length > 0 && axe.commons.dom.isModalOpen()) {\n          return true;\n        }\n        return relatedNodes.length === 0;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "No focusable elements contained within element",
          "fail": "Focusable content should have tabindex='-1' or be removed from the DOM"
        }
      }
    },
    {
      "id": "no-implicit-explicit-label",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons7 = axe.commons, aria = _axe$commons7.aria, text = _axe$commons7.text;\n        var role = aria.getRole(node, {\n          noImplicit: true\n        });\n        this.data(role);\n        var labelText = text.sanitize(text.labelText(virtualNode)).toLowerCase();\n        var accText = text.sanitize(text.accessibleText(node)).toLowerCase();\n        if (!accText && !labelText) {\n          return false;\n        }\n        if (!accText && labelText) {\n          return undefined;\n        }\n        if (!accText.includes(labelText)) {\n          return undefined;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "There is no mismatch between a <label> and accessible name",
          "incomplete": "Check that the <label> does not need be part of the ARIA ${data} field's name"
        }
      }
    },
    {
      "id": "aria-required-attr",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var missing = [];\n        var _axe$commons$forms = axe.commons.forms, isNativeTextbox = _axe$commons$forms.isNativeTextbox, isNativeSelect = _axe$commons$forms.isNativeSelect, isAriaTextbox = _axe$commons$forms.isAriaTextbox, isAriaListbox = _axe$commons$forms.isAriaListbox, isAriaCombobox = _axe$commons$forms.isAriaCombobox, isAriaRange = _axe$commons$forms.isAriaRange;\n        var preChecks = {\n          'aria-valuenow': function ariaValuenow() {\n            return !(isNativeTextbox(node) || isNativeSelect(node) || isAriaTextbox(node) || isAriaListbox(node) || isAriaCombobox(node) || isAriaRange(node) && node.hasAttribute('aria-valuenow'));\n          }\n        };\n        if (node.hasAttributes()) {\n          var role = node.getAttribute('role');\n          var required = axe.commons.aria.requiredAttr(role);\n          if (Array.isArray(options[role])) {\n            required = axe.utils.uniqueArray(options[role], required);\n          }\n          if (role && required) {\n            for (var i = 0, l = required.length; i < l; i++) {\n              var attr = required[i];\n              if (!node.getAttribute(attr) && (preChecks[attr] ? preChecks[attr]() : true)) {\n                missing.push(attr);\n              }\n            }\n          }\n        }\n        if (missing.length) {\n          this.data(missing);\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "All required ARIA attributes are present",
          "fail": {
            "singular": "Required ARIA attribute not present: ${data.values}",
            "plural": "Required ARIA attributes not present: ${data.values}"
          }
        }
      }
    },
    {
      "id": "aria-required-children",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var requiredOwned = axe.commons.aria.requiredOwned;\n        var implicitNodes = axe.commons.aria.implicitNodes;\n        var matchesSelector = axe.utils.matchesSelector;\n        var idrefs = axe.commons.dom.idrefs;\n        var hasContentVirtual = axe.commons.dom.hasContentVirtual;\n        var reviewEmpty = options && Array.isArray(options.reviewEmpty) ? options.reviewEmpty : [];\n        function owns(node, virtualTree, role, ariaOwned) {\n          if (node === null) {\n            return false;\n          }\n          var implicit = implicitNodes(role);\n          var selector = [ '[role=\"' + role + '\"]' ];\n          if (implicit) {\n            selector = selector.concat(implicit.map(function(implicitSelector) {\n              return implicitSelector + ':not([role])';\n            }));\n          }\n          selector = selector.join(',');\n          return ariaOwned ? matchesSelector(node, selector) || !!axe.utils.querySelectorAll(virtualTree, selector)[0] : !!axe.utils.querySelectorAll(virtualTree, selector)[0];\n        }\n        function ariaOwns(nodes, role) {\n          for (var index = 0; index < nodes.length; index++) {\n            var _node = nodes[index];\n            if (_node === null) {\n              continue;\n            }\n            var virtualTree = axe.utils.getNodeFromTree(_node);\n            if (owns(_node, virtualTree, role, true)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function missingRequiredChildren(node, childRoles, all, role) {\n          var missing = [], ownedElements = idrefs(node, 'aria-owns');\n          for (var index = 0; index < childRoles.length; index++) {\n            var childRole = childRoles[index];\n            if (owns(node, virtualNode, childRole) || ariaOwns(ownedElements, childRole)) {\n              if (!all) {\n                return null;\n              }\n            } else {\n              if (all) {\n                missing.push(childRole);\n              }\n            }\n          }\n          if (role === 'combobox') {\n            var textboxIndex = missing.indexOf('textbox');\n            var textTypeInputs = [ 'text', 'search', 'email', 'url', 'tel' ];\n            if (textboxIndex >= 0 && node.nodeName.toUpperCase() === 'INPUT' && textTypeInputs.includes(node.type) || owns(node, virtualNode, 'searchbox') || ariaOwns(ownedElements, 'searchbox')) {\n              missing.splice(textboxIndex, 1);\n            }\n            var expandedChildRoles = [ 'listbox', 'tree', 'grid', 'dialog' ];\n            var expandedValue = node.getAttribute('aria-expanded');\n            var expanded = expandedValue && expandedValue !== 'false';\n            var popupRole = (node.getAttribute('aria-haspopup') || 'listbox').toLowerCase();\n            for (var _index = 0; _index < expandedChildRoles.length; _index++) {\n              var expandedChildRole = expandedChildRoles[_index];\n              if (expanded && expandedChildRole === popupRole) {\n                continue;\n              }\n              var missingIndex = missing.indexOf(expandedChildRole);\n              if (missingIndex >= 0) {\n                missing.splice(missingIndex, 1);\n              }\n            }\n          }\n          if (missing.length) {\n            return missing;\n          }\n          if (!all && childRoles.length) {\n            return childRoles;\n          }\n          return null;\n        }\n        function hasDecendantWithRole(node) {\n          return node.children && node.children.some(function(child) {\n            var role = axe.commons.aria.getRole(child);\n            return ![ 'presentation', 'none', null ].includes(role) || hasDecendantWithRole(child);\n          });\n        }\n        var role = node.getAttribute('role');\n        var required = requiredOwned(role);\n        if (!required) {\n          return true;\n        }\n        var all = false;\n        var childRoles = required.one;\n        if (!childRoles) {\n          all = true;\n          childRoles = required.all;\n        }\n        var missing = missingRequiredChildren(node, childRoles, all, role);\n        if (!missing) {\n          return true;\n        }\n        this.data(missing);\n        if (reviewEmpty.includes(role) && !hasContentVirtual(virtualNode, false, true) && !hasDecendantWithRole(virtualNode) && idrefs(node, 'aria-owns').length === 0) {\n          return undefined;\n        } else {\n          return false;\n        }\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Required ARIA children are present",
          "fail": {
            "singular": "Required ARIA child role not present: ${data.values}",
            "plural": "Required ARIA children role not present: ${data.values}"
          },
          "incomplete": {
            "singular": "Expecting ARIA child role to be added: ${data.values}",
            "plural": "Expecting ARIA children role to be added: ${data.values}"
          }
        }
      }
    },
    {
      "id": "aria-required-parent",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        function getSelector(role) {\n          var impliedNative = axe.commons.aria.implicitNodes(role) || [];\n          return impliedNative.concat('[role=\"' + role + '\"]').join(',');\n        }\n        function getMissingContext(virtualNode, requiredContext, includeElement) {\n          var index, length, role = virtualNode.actualNode.getAttribute('role'), missing = [];\n          if (!requiredContext) {\n            requiredContext = axe.commons.aria.requiredContext(role);\n          }\n          if (!requiredContext) {\n            return null;\n          }\n          for (index = 0, length = requiredContext.length; index < length; index++) {\n            if (includeElement && axe.utils.matchesSelector(virtualNode.actualNode, getSelector(requiredContext[index]))) {\n              return null;\n            }\n            if (axe.commons.dom.findUpVirtual(virtualNode, getSelector(requiredContext[index]))) {\n              return null;\n            } else {\n              missing.push(requiredContext[index]);\n            }\n          }\n          return missing;\n        }\n        function getAriaOwners(element) {\n          var owners = [], o = null;\n          while (element) {\n            if (element.getAttribute('id')) {\n              var id = axe.utils.escapeSelector(element.getAttribute('id'));\n              var doc = axe.commons.dom.getRootNode(element);\n              o = doc.querySelector('[aria-owns~='.concat(id, ']'));\n              if (o) {\n                owners.push(o);\n              }\n            }\n            element = element.parentElement;\n          }\n          return owners.length ? owners : null;\n        }\n        var missingParents = getMissingContext(virtualNode);\n        if (!missingParents) {\n          return true;\n        }\n        var owners = getAriaOwners(node);\n        if (owners) {\n          for (var i = 0, l = owners.length; i < l; i++) {\n            missingParents = getMissingContext(axe.utils.getNodeFromTree(owners[i]), missingParents, true);\n            if (!missingParents) {\n              return true;\n            }\n          }\n        }\n        this.data(missingParents);\n        return false;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Required ARIA parent role present",
          "fail": {
            "singular": "Required ARIA parent role not present: ${data.values}",
            "plural": "Required ARIA parents role not present: ${data.values}"
          }
        }
      }
    },
    {
      "id": "aria-roledescription",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var role = axe.commons.aria.getRole(node);\n        var supportedRoles = options.supportedRoles || [];\n        if (supportedRoles.includes(role)) {\n          return true;\n        }\n        if (role && role !== 'presentation' && role !== 'none') {\n          return undefined;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "aria-roledescription used on a supported semantic role",
          "incomplete": "Check that the aria-roledescription is announced by supported screen readers",
          "fail": "Give the element a role that supports aria-roledescription"
        }
      }
    },
    {
      "id": "fallbackrole",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.utils.tokenList(virtualNode.attr('role')).length > 1;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Only one role value used",
          "fail": "Use only one role value, since fallback roles are not supported in older browsers"
        }
      }
    },
    {
      "id": "invalidrole",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tokenList = axe.utils.tokenList;\n        var aria = axe.commons.aria;\n        var allRoles = tokenList(virtualNode.attr('role'));\n        var allInvalid = allRoles.every(function(role) {\n          return !aria.isValidRole(role, {\n            allowAbstract: true\n          });\n        });\n        if (allInvalid) {\n          this.data(allRoles);\n          return true;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "ARIA role is valid",
          "fail": {
            "singular": "Role must be one of the valid ARIA roles: ${data.values}",
            "plural": "Roles must be one of the valid ARIA roles: ${data.values}"
          }
        }
      }
    },
    {
      "id": "abstractrole",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var abstractRoles = axe.utils.tokenList(virtualNode.attr('role')).filter(function(role) {\n          return axe.commons.aria.getRoleType(role) === 'abstract';\n        });\n        if (abstractRoles.length > 0) {\n          this.data(abstractRoles);\n          return true;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Abstract roles are not used",
          "fail": {
            "singular": "Abstract role cannot be directly used: ${data.values}",
            "plural": "Abstract roles cannot be directly used: ${data.values}"
          }
        }
      }
    },
    {
      "id": "unsupportedrole",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.commons.aria.isUnsupportedRole(axe.commons.aria.getRole(node));\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "ARIA role is supported",
          "fail": "The role used is not widely supported in screen readers and assistive technologies: ${data.values}"
        }
      }
    },
    {
      "id": "has-visible-text",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.commons.text.accessibleTextVirtual(virtualNode).length > 0;\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Element has text that is visible to screen readers",
          "fail": "Element does not have text that is visible to screen readers"
        }
      }
    },
    {
      "id": "aria-valid-attr-value",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = Array.isArray(options) ? options : [];\n        var needsReview = '';\n        var messageKey = '';\n        var invalid = [];\n        var aria = /^aria-/;\n        var attrs = axe.utils.getNodeAttributes(node);\n        var skipAttrs = [ 'aria-errormessage' ];\n        var preChecks = {\n          'aria-controls': function ariaControls() {\n            return node.getAttribute('aria-expanded') !== 'false' && node.getAttribute('aria-selected') !== 'false';\n          },\n          'aria-current': function ariaCurrent() {\n            if (!axe.commons.aria.validateAttrValue(node, 'aria-current')) {\n              needsReview = 'aria-current=\"'.concat(node.getAttribute('aria-current'), '\"');\n              messageKey = 'ariaCurrent';\n            }\n            return;\n          },\n          'aria-owns': function ariaOwns() {\n            return node.getAttribute('aria-expanded') !== 'false';\n          },\n          'aria-describedby': function ariaDescribedby() {\n            if (!axe.commons.aria.validateAttrValue(node, 'aria-describedby')) {\n              needsReview = 'aria-describedby=\"'.concat(node.getAttribute('aria-describedby'), '\"');\n              messageKey = 'noId';\n            }\n            return;\n          }\n        };\n        for (var i = 0, l = attrs.length; i < l; i++) {\n          var attr = attrs[i];\n          var attrName = attr.name;\n          if (!skipAttrs.includes(attrName) && options.indexOf(attrName) === -1 && aria.test(attrName) && (preChecks[attrName] ? preChecks[attrName]() : true) && !axe.commons.aria.validateAttrValue(node, attrName)) {\n            invalid.push(''.concat(attrName, '=\"').concat(attr.nodeValue, '\"'));\n          }\n        }\n        if (needsReview) {\n          this.data({\n            messageKey: messageKey,\n            needsReview: needsReview\n          });\n          return undefined;\n        }\n        if (invalid.length) {\n          this.data(invalid);\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "ARIA attribute values are valid",
          "fail": {
            "singular": "Invalid ARIA attribute value: ${data.values}",
            "plural": "Invalid ARIA attribute values: ${data.values}"
          },
          "incomplete": {
            "noId": "ARIA attribute element ID does not exist on the page: ${data.needsReview}",
            "ariaCurrent": "ARIA attribute value is invalid and will be treated as \"aria-current=true\": ${data.needsReview}"
          }
        }
      }
    },
    {
      "id": "aria-errormessage",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons6 = axe.commons, aria = _axe$commons6.aria, dom = _axe$commons6.dom;\n        options = Array.isArray(options) ? options : [];\n        var attr = node.getAttribute('aria-errormessage');\n        var hasAttr = node.hasAttribute('aria-errormessage');\n        var doc = dom.getRootNode(node);\n        function validateAttrValue(attr) {\n          if (attr.trim() === '') {\n            return aria.lookupTable.attributes['aria-errormessage'].allowEmpty;\n          }\n          var idref = attr && doc.getElementById(attr);\n          if (idref) {\n            return idref.getAttribute('role') === 'alert' || idref.getAttribute('aria-live') === 'assertive' || axe.utils.tokenList(node.getAttribute('aria-describedby') || '').indexOf(attr) > -1;\n          }\n        }\n        if (options.indexOf(attr) === -1 && hasAttr) {\n          if (!validateAttrValue(attr)) {\n            this.data(axe.utils.tokenList(attr));\n            return false;\n          }\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Uses a supported aria-errormessage technique",
          "fail": {
            "singular": "aria-errormessage value `${data.values}` must use a technique to announce the message (e.g., aria-live, aria-describedby, role=alert, etc.)",
            "plural": "aria-errormessage values `${data.values}` must use a technique to announce the message (e.g., aria-live, aria-describedby, role=alert, etc.)"
          }
        }
      }
    },
    {
      "id": "aria-valid-attr",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = Array.isArray(options) ? options : [];\n        var invalid = [], aria = /^aria-/;\n        var attr, attrs = axe.utils.getNodeAttributes(node);\n        for (var i = 0, l = attrs.length; i < l; i++) {\n          attr = attrs[i].name;\n          if (options.indexOf(attr) === -1 && aria.test(attr) && !axe.commons.aria.validateAttr(attr)) {\n            invalid.push(attr);\n          }\n        }\n        if (invalid.length) {\n          this.data(invalid);\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "ARIA attribute name is valid",
          "fail": {
            "singular": "Invalid ARIA attribute name: ${data.values}",
            "plural": "Invalid ARIA attribute names: ${data.values}"
          }
        }
      }
    },
    {
      "id": "caption",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tracks = axe.utils.querySelectorAll(virtualNode, 'track');\n        var hasCaptions = tracks.some(function(_ref7) {\n          var actualNode = _ref7.actualNode;\n          return (actualNode.getAttribute('kind') || '').toLowerCase() === 'captions';\n        });\n        return hasCaptions ? false : undefined;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "The multimedia element has a captions track",
          "incomplete": "Check that captions is available for the element"
        }
      }
    },
    {
      "id": "autocomplete-valid",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var autocomplete = virtualNode.attr('autocomplete') || '';\n        return axe.commons.text.isValidAutocomplete(autocomplete, options);\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "the autocomplete attribute is correctly formatted",
          "fail": "the autocomplete attribute is incorrectly formatted"
        }
      }
    },
    {
      "id": "autocomplete-appropriate",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (virtualNode.props.nodeName !== 'input') {\n          return true;\n        }\n        var number = [ 'text', 'search', 'number' ];\n        var url = [ 'text', 'search', 'url' ];\n        var allowedTypesMap = {\n          bday: [ 'text', 'search', 'date' ],\n          email: [ 'text', 'search', 'email' ],\n          'cc-exp': [ 'text', 'search', 'month' ],\n          'street-address': [ 'text' ],\n          tel: [ 'text', 'search', 'tel' ],\n          'cc-exp-month': number,\n          'cc-exp-year': number,\n          'transaction-amount': number,\n          'bday-day': number,\n          'bday-month': number,\n          'bday-year': number,\n          'new-password': [ 'text', 'search', 'password' ],\n          'current-password': [ 'text', 'search', 'password' ],\n          url: url,\n          photo: url,\n          impp: url\n        };\n        if (_typeof(options) === 'object') {\n          Object.keys(options).forEach(function(key) {\n            if (!allowedTypesMap[key]) {\n              allowedTypesMap[key] = [];\n            }\n            allowedTypesMap[key] = allowedTypesMap[key].concat(options[key]);\n          });\n        }\n        var autocomplete = virtualNode.attr('autocomplete');\n        var autocompleteTerms = autocomplete.split(/\\s+/g).map(function(term) {\n          return term.toLowerCase();\n        });\n        var purposeTerm = autocompleteTerms[autocompleteTerms.length - 1];\n        if (axe.commons.text.autocomplete.stateTerms.includes(purposeTerm)) {\n          return true;\n        }\n        var allowedTypes = allowedTypesMap[purposeTerm];\n        var type = virtualNode.hasAttr('type') ? axe.commons.text.sanitize(virtualNode.attr('type')).toLowerCase() : 'text';\n        type = axe.utils.validInputTypes().includes(type) ? type : 'text';\n        if (typeof allowedTypes === 'undefined') {\n          return type === 'text';\n        }\n        return allowedTypes.includes(type);\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "the autocomplete value is on an appropriate element",
          "fail": "the autocomplete value is inappropriate for this type of input"
        }
      }
    },
    {
      "id": "avoid-inline-spacing",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var inlineSpacingCssProperties = [ 'line-height', 'letter-spacing', 'word-spacing' ];\n        var overriddenProperties = inlineSpacingCssProperties.filter(function(property) {\n          if (node.style.getPropertyPriority(property) === 'important') {\n            return property;\n          }\n        });\n        if (overriddenProperties.length > 0) {\n          this.data(overriddenProperties);\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "No inline styles with '!important' that affect text spacing has been specified",
          "fail": {
            "singular": "Remove '!important' from inline style ${data.values}, as overriding this is not supported by most browsers",
            "plural": "Remove '!important' from inline styles ${data.values}, as overriding this is not supported by most browsers"
          }
        }
      }
    },
    {
      "id": "is-on-screen",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.commons.dom.isVisible(node, false) && !axe.commons.dom.isOffscreen(node);\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Element is not visible",
          "fail": "Element is visible"
        }
      }
    },
    {
      "id": "button-has-visible-text",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var nodeName = node.nodeName.toUpperCase();\n        var role = node.getAttribute('role');\n        var label;\n        if (nodeName === 'BUTTON' || role === 'button' && nodeName !== 'INPUT') {\n          label = axe.commons.text.accessibleTextVirtual(virtualNode);\n          this.data(label);\n          return !!label;\n        } else {\n          return false;\n        }\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Element has inner text that is visible to screen readers",
          "fail": "Element does not have inner text that is visible to screen readers"
        }
      }
    },
    {
      "id": "role-presentation",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return node.getAttribute('role') === 'presentation';\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Element's default semantics were overriden with role=\"presentation\"",
          "fail": "Element's default semantics were not overridden with role=\"presentation\""
        }
      }
    },
    {
      "id": "role-none",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return node.getAttribute('role') === 'none';\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Element's default semantics were overriden with role=\"none\"",
          "fail": "Element's default semantics were not overridden with role=\"none\""
        }
      }
    },
    {
      "id": "internal-link-present",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var links = axe.utils.querySelectorAll(virtualNode, 'a[href]');\n        return links.some(function(vLink) {\n          return /^#[^/!]/.test(vLink.actualNode.getAttribute('href'));\n        });\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Valid skip link found",
          "fail": "No valid skip link found"
        }
      }
    },
    {
      "id": "header-present",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!axe.utils.querySelectorAll(virtualNode, 'h1, h2, h3, h4, h5, h6, [role=\"heading\"]')[0];\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Page has a header",
          "fail": "Page does not have a header"
        }
      }
    },
    {
      "id": "landmark",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return axe.utils.querySelectorAll(virtualNode, 'main, [role=\"main\"]').length > 0;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Page has a landmark region",
          "fail": "Page does not have a landmark region"
        }
      }
    },
    {
      "id": "group-labelledby",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons10 = axe.commons, dom = _axe$commons10.dom, text = _axe$commons10.text;\n        var type = axe.utils.escapeSelector(node.type);\n        var name = axe.utils.escapeSelector(node.name);\n        var doc = dom.getRootNode(node);\n        var data = {\n          name: node.name,\n          type: node.type\n        };\n        var matchingNodes = Array.from(doc.querySelectorAll('input[type=\"'.concat(type, '\"][name=\"').concat(name, '\"]')));\n        if (matchingNodes.length <= 1) {\n          this.data(data);\n          return true;\n        }\n        var sharedLabels = dom.idrefs(node, 'aria-labelledby').filter(function(label) {\n          return !!label;\n        });\n        var uniqueLabels = sharedLabels.slice();\n        matchingNodes.forEach(function(groupItem) {\n          if (groupItem === node) {\n            return;\n          }\n          var labels = dom.idrefs(groupItem, 'aria-labelledby').filter(function(newLabel) {\n            return newLabel;\n          });\n          sharedLabels = sharedLabels.filter(function(sharedLabel) {\n            return labels.includes(sharedLabel);\n          });\n          uniqueLabels = uniqueLabels.filter(function(uniqueLabel) {\n            return !labels.includes(uniqueLabel);\n          });\n        });\n        var accessibleTextOptions = {\n          inLabelledByContext: true\n        };\n        uniqueLabels = uniqueLabels.filter(function(labelNode) {\n          return text.accessibleText(labelNode, accessibleTextOptions);\n        });\n        sharedLabels = sharedLabels.filter(function(labelNode) {\n          return text.accessibleText(labelNode, accessibleTextOptions);\n        });\n        if (uniqueLabels.length > 0 && sharedLabels.length > 0) {\n          this.data(data);\n          return true;\n        }\n        if (uniqueLabels.length > 0 && sharedLabels.length === 0) {\n          data.messageKey = 'no-shared-label';\n        } else if (uniqueLabels.length === 0 && sharedLabels.length > 0) {\n          data.messageKey = 'no-unique-label';\n        }\n        this.data(data);\n        return false;\n      }",
      "after": "function after(results, options) {\n        var seen = {};\n        return results.filter(function(result) {\n          var data = result.data;\n          if (data) {\n            seen[data.type] = seen[data.type] || {};\n            if (!seen[data.type][data.name]) {\n              seen[data.type][data.name] = true;\n              return true;\n            }\n          }\n          return false;\n        });\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Elements with the name \"${data.name}\" have both a shared label, and a unique label, referenced through aria-labelledby",
          "fail": {
            "default": "Elements with the name \"${data.name}\" do not all have both a shared label, and a unique label referenced through aria-labelledby",
            "no-shared-label": "Elements with the name \"${data.name}\" do not all have a shared label referenced through aria-labelledby",
            "no-unique-label": "Elements with the name \"${data.name}\" do not all have a unique label referenced through aria-labelledby"
          }
        }
      }
    },
    {
      "id": "fieldset",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var failureCode, self = this;\n        function getUnrelatedElements(parent, name) {\n          return axe.utils.toArray(parent.querySelectorAll('select,textarea,button,input:not([name=\"' + name + '\"]):not([type=\"hidden\"])'));\n        }\n        function checkFieldset(group, name) {\n          var firstNode = group.firstElementChild;\n          if (!firstNode || firstNode.nodeName.toUpperCase() !== 'LEGEND') {\n            self.relatedNodes([ group ]);\n            failureCode = 'no-legend';\n            return false;\n          }\n          if (!axe.commons.text.accessibleText(firstNode)) {\n            self.relatedNodes([ firstNode ]);\n            failureCode = 'empty-legend';\n            return false;\n          }\n          var otherElements = getUnrelatedElements(group, name);\n          if (otherElements.length) {\n            self.relatedNodes(otherElements);\n            failureCode = 'mixed-inputs';\n            return false;\n          }\n          return true;\n        }\n        function checkARIAGroup(group, name) {\n          var hasLabelledByText = axe.commons.dom.idrefs(group, 'aria-labelledby').some(function(element) {\n            return element && axe.commons.text.accessibleText(element);\n          });\n          var ariaLabel = group.getAttribute('aria-label');\n          if (!hasLabelledByText && !(ariaLabel && axe.commons.text.sanitize(ariaLabel))) {\n            self.relatedNodes(group);\n            failureCode = 'no-group-label';\n            return false;\n          }\n          var otherElements = getUnrelatedElements(group, name);\n          if (otherElements.length) {\n            self.relatedNodes(otherElements);\n            failureCode = 'group-mixed-inputs';\n            return false;\n          }\n          return true;\n        }\n        function spliceCurrentNode(nodes, current) {\n          return axe.utils.toArray(nodes).filter(function(candidate) {\n            return candidate !== current;\n          });\n        }\n        function runCheck(virtualNode) {\n          var name = axe.utils.escapeSelector(virtualNode.actualNode.name);\n          var root = axe.commons.dom.getRootNode(virtualNode.actualNode);\n          var matchingNodes = root.querySelectorAll('input[type=\"' + axe.utils.escapeSelector(virtualNode.actualNode.type) + '\"][name=\"' + name + '\"]');\n          if (matchingNodes.length < 2) {\n            return true;\n          }\n          var fieldset = axe.commons.dom.findUpVirtual(virtualNode, 'fieldset');\n          var group = axe.commons.dom.findUpVirtual(virtualNode, '[role=\"group\"]' + (virtualNode.actualNode.type === 'radio' ? ',[role=\"radiogroup\"]' : ''));\n          if (!group && !fieldset) {\n            failureCode = 'no-group';\n            self.relatedNodes(spliceCurrentNode(matchingNodes, virtualNode.actualNode));\n            return false;\n          } else if (fieldset) {\n            return checkFieldset(fieldset, name);\n          } else {\n            return checkARIAGroup(group, name);\n          }\n        }\n        var data = {\n          name: node.getAttribute('name'),\n          type: node.getAttribute('type')\n        };\n        var result = runCheck(virtualNode);\n        if (!result) {\n          data.messageKey = failureCode;\n        }\n        this.data(data);\n        return result;\n      }",
      "after": "function after(results, options) {\n        var seen = {};\n        return results.filter(function(result) {\n          if (result.result) {\n            return true;\n          }\n          var data = result.data;\n          if (data) {\n            seen[data.type] = seen[data.type] || {};\n            if (!seen[data.type][data.name]) {\n              seen[data.type][data.name] = [ data ];\n              return true;\n            }\n            var hasBeenSeen = seen[data.type][data.name].some(function(candidate) {\n              return candidate.failureCode === data.failureCode;\n            });\n            if (!hasBeenSeen) {\n              seen[data.type][data.name].push(data);\n            }\n            return !hasBeenSeen;\n          }\n          return false;\n        });\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Element is contained in a fieldset",
          "fail": {
            "default": "Element does not have a containing fieldset or ARIA group",
            "no-legend": "Fieldset does not have a legend as its first child",
            "empty-legend": "Legend does not have text that is visible to screen readers",
            "mixed-inputs": "Fieldset contains unrelated inputs",
            "no-group-label": "ARIA group does not have aria-label or aria-labelledby",
            "group-mixed-inputs": "ARIA group contains unrelated inputs"
          }
        }
      }
    },
    {
      "id": "color-contrast",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons8 = axe.commons, dom = _axe$commons8.dom, color = _axe$commons8.color, text = _axe$commons8.text;\n        if (!dom.isVisible(node, false)) {\n          return true;\n        }\n        var visibleText = text.visibleVirtual(virtualNode, false, true);\n        var ignoreUnicode = !!(options || {}).ignoreUnicode;\n        var textContainsOnlyUnicode = text.hasUnicode(visibleText, {\n          nonBmp: true\n        }) && text.sanitize(text.removeUnicode(visibleText, {\n          nonBmp: true\n        })) === '';\n        if (textContainsOnlyUnicode && ignoreUnicode) {\n          this.data({\n            messageKey: 'nonBmp'\n          });\n          return undefined;\n        }\n        var noScroll = !!(options || {}).noScroll;\n        var bgNodes = [];\n        var bgColor = color.getBackgroundColor(node, bgNodes, noScroll);\n        var fgColor = color.getForegroundColor(node, noScroll, bgColor);\n        var nodeStyle = window.getComputedStyle(node);\n        var fontSize = parseFloat(nodeStyle.getPropertyValue('font-size'));\n        var fontWeight = parseFloat(nodeStyle.getPropertyValue('font-weight'));\n        var bold = !isNaN(fontWeight) && fontWeight >= 700;\n        var cr = color.hasValidContrastRatio(bgColor, fgColor, fontSize, bold);\n        var truncatedResult = Math.floor(cr.contrastRatio * 100) / 100;\n        var missing;\n        if (bgColor === null) {\n          missing = color.incompleteData.get('bgColor');\n        }\n        var equalRatio = truncatedResult === 1;\n        var shortTextContent = visibleText.length === 1;\n        var ignoreLength = !!(options || {}).ignoreLength;\n        if (equalRatio) {\n          missing = color.incompleteData.set('bgColor', 'equalRatio');\n        } else if (shortTextContent && !ignoreLength) {\n          missing = 'shortTextContent';\n        }\n        var data = {\n          fgColor: fgColor ? fgColor.toHexString() : undefined,\n          bgColor: bgColor ? bgColor.toHexString() : undefined,\n          contrastRatio: cr ? truncatedResult : undefined,\n          fontSize: ''.concat((fontSize * 72 / 96).toFixed(1), 'pt (').concat(fontSize, 'px)'),\n          fontWeight: bold ? 'bold' : 'normal',\n          messageKey: missing,\n          expectedContrastRatio: cr.expectedContrastRatio + ':1'\n        };\n        this.data(data);\n        if (fgColor === null || bgColor === null || equalRatio || shortTextContent && !ignoreLength && !cr.isValid) {\n          missing = null;\n          color.incompleteData.clear();\n          this.relatedNodes(bgNodes);\n          return undefined;\n        }\n        if (!cr.isValid) {\n          this.relatedNodes(bgNodes);\n        }\n        return cr.isValid;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Element has sufficient color contrast of ${data.contrastRatio}",
          "fail": "Element has insufficient color contrast of ${data.contrastRatio} (foreground color: ${data.fgColor}, background color: ${data.bgColor}, font size: ${data.fontSize}, font weight: ${data.fontWeight}). Expected contrast ratio of ${data.expectedContrastRatio}",
          "incomplete": {
            "default": "Unable to determine contrast ratio",
            "bgImage": "Element's background color could not be determined due to a background image",
            "bgGradient": "Element's background color could not be determined due to a background gradient",
            "imgNode": "Element's background color could not be determined because element contains an image node",
            "bgOverlap": "Element's background color could not be determined because it is overlapped by another element",
            "fgAlpha": "Element's foreground color could not be determined because of alpha transparency",
            "elmPartiallyObscured": "Element's background color could not be determined because it's partially obscured by another element",
            "elmPartiallyObscuring": "Element's background color could not be determined because it partially overlaps other elements",
            "outsideViewport": "Element's background color could not be determined because it's outside the viewport",
            "equalRatio": "Element has a 1:1 contrast ratio with the background",
            "shortTextContent": "Element content is too short to determine if it is actual text content",
            "nonBmp": "Element content contains only non-text characters"
          }
        }
      }
    },
    {
      "id": "css-orientation-lock",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _ref9 = context || {}, _ref9$cssom = _ref9.cssom, cssom = _ref9$cssom === void 0 ? undefined : _ref9$cssom;\n        var _ref10 = options || {}, _ref10$degreeThreshol = _ref10.degreeThreshold, degreeThreshold = _ref10$degreeThreshol === void 0 ? 0 : _ref10$degreeThreshol;\n        if (!cssom || !cssom.length) {\n          return undefined;\n        }\n        var isLocked = false;\n        var relatedElements = [];\n        var rulesGroupByDocumentFragment = groupCssomByDocument(cssom);\n        var _loop = function _loop() {\n          var key = _Object$keys[_i2];\n          var _rulesGroupByDocument = rulesGroupByDocumentFragment[key], root = _rulesGroupByDocument.root, rules = _rulesGroupByDocument.rules;\n          var orientationRules = rules.filter(isMediaRuleWithOrientation);\n          if (!orientationRules.length) {\n            return 'continue';\n          }\n          orientationRules.forEach(function(_ref16) {\n            var cssRules = _ref16.cssRules;\n            Array.from(cssRules).forEach(function(cssRule) {\n              var locked = getIsOrientationLocked(cssRule);\n              if (locked && cssRule.selectorText.toUpperCase() !== 'HTML') {\n                var elms = Array.from(root.querySelectorAll(cssRule.selectorText)) || [];\n                relatedElements = relatedElements.concat(elms);\n              }\n              isLocked = isLocked || locked;\n            });\n          });\n        };\n        for (var _i2 = 0, _Object$keys = Object.keys(rulesGroupByDocumentFragment); _i2 < _Object$keys.length; _i2++) {\n          var _ret = _loop();\n          if (_ret === 'continue') {\n            continue;\n          }\n        }\n        if (!isLocked) {\n          return true;\n        }\n        if (relatedElements.length) {\n          this.relatedNodes(relatedElements);\n        }\n        return false;\n        function groupCssomByDocument(cssObjectModel) {\n          return cssObjectModel.reduce(function(out, _ref11) {\n            var sheet = _ref11.sheet, root = _ref11.root, shadowId = _ref11.shadowId;\n            var key = shadowId ? shadowId : 'topDocument';\n            if (!out[key]) {\n              out[key] = {\n                root: root,\n                rules: []\n              };\n            }\n            if (!sheet || !sheet.cssRules) {\n              return out;\n            }\n            var rules = Array.from(sheet.cssRules);\n            out[key].rules = out[key].rules.concat(rules);\n            return out;\n          }, {});\n        }\n        function isMediaRuleWithOrientation(_ref12) {\n          var type = _ref12.type, cssText = _ref12.cssText;\n          if (type !== 4) {\n            return false;\n          }\n          return /orientation:\\s*landscape/i.test(cssText) || /orientation:\\s*portrait/i.test(cssText);\n        }\n        function getIsOrientationLocked(_ref13) {\n          var selectorText = _ref13.selectorText, style = _ref13.style;\n          if (!selectorText || style.length <= 0) {\n            return false;\n          }\n          var transformStyle = style.transform || style.webkitTransform || style.msTransform || false;\n          if (!transformStyle) {\n            return false;\n          }\n          var matches = transformStyle.match(/(rotate|rotateZ|rotate3d|matrix|matrix3d)\\(([^)]+)\\)(?!.*(rotate|rotateZ|rotate3d|matrix|matrix3d))/);\n          if (!matches) {\n            return false;\n          }\n          var _matches = _slicedToArray(matches, 3), transformFn = _matches[1], transformFnValue = _matches[2];\n          var degrees = getRotationInDegrees(transformFn, transformFnValue);\n          if (!degrees) {\n            return false;\n          }\n          degrees = Math.abs(degrees);\n          if (Math.abs(degrees - 180) % 180 <= degreeThreshold) {\n            return false;\n          }\n          return Math.abs(degrees - 90) % 90 <= degreeThreshold;\n        }\n        function getRotationInDegrees(transformFunction, transformFnValue) {\n          switch (transformFunction) {\n           case 'rotate':\n           case 'rotateZ':\n            return getAngleInDegrees(transformFnValue);\n\n           case 'rotate3d':\n            var _transformFnValue$spl = transformFnValue.split(',').map(function(value) {\n              return value.trim();\n            }), _transformFnValue$spl2 = _slicedToArray(_transformFnValue$spl, 4), z = _transformFnValue$spl2[2], angleWithUnit = _transformFnValue$spl2[3];\n            if (parseInt(z) === 0) {\n              return;\n            }\n            return getAngleInDegrees(angleWithUnit);\n\n           case 'matrix':\n           case 'matrix3d':\n            return getAngleInDegreesFromMatrixTransform(transformFnValue);\n\n           default:\n            return;\n          }\n        }\n        function getAngleInDegrees(angleWithUnit) {\n          var _ref14 = angleWithUnit.match(/(deg|grad|rad|turn)/) || [], _ref15 = _slicedToArray(_ref14, 1), unit = _ref15[0];\n          if (!unit) {\n            return;\n          }\n          var angle = parseFloat(angleWithUnit.replace(unit, ''));\n          switch (unit) {\n           case 'rad':\n            return convertRadToDeg(angle);\n\n           case 'grad':\n            return convertGradToDeg(angle);\n\n           case 'turn':\n            return convertTurnToDeg(angle);\n\n           case 'deg':\n           default:\n            return parseInt(angle);\n          }\n        }\n        function getAngleInDegreesFromMatrixTransform(transformFnValue) {\n          var values = transformFnValue.split(',');\n          if (values.length <= 6) {\n            var _values = _slicedToArray(values, 2), a = _values[0], _b = _values[1];\n            var radians = Math.atan2(parseFloat(_b), parseFloat(a));\n            return convertRadToDeg(radians);\n          }\n          var sinB = parseFloat(values[8]);\n          var b = Math.asin(sinB);\n          var cosB = Math.cos(b);\n          var rotateZRadians = Math.acos(parseFloat(values[0]) / cosB);\n          return convertRadToDeg(rotateZRadians);\n        }\n        function convertRadToDeg(radians) {\n          return Math.round(radians * (180 / Math.PI));\n        }\n        function convertGradToDeg(grad) {\n          grad = grad % 400;\n          if (grad < 0) {\n            grad += 400;\n          }\n          return Math.round(grad / 400 * 360);\n        }\n        function convertTurnToDeg(turn) {\n          return Math.round(360 / (1 / turn));\n        }\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Display is operable, and orientation lock does not exist",
          "fail": "CSS Orientation lock is applied, and makes display inoperable",
          "incomplete": "CSS Orientation lock cannot be determined"
        }
      }
    },
    {
      "id": "structured-dlitems",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var children = virtualNode.children;\n        if (!children || !children.length) {\n          return false;\n        }\n        var hasDt = false, hasDd = false, nodeName;\n        for (var i = 0; i < children.length; i++) {\n          nodeName = children[i].actualNode.nodeName.toUpperCase();\n          if (nodeName === 'DT') {\n            hasDt = true;\n          }\n          if (hasDt && nodeName === 'DD') {\n            return false;\n          }\n          if (nodeName === 'DD') {\n            hasDd = true;\n          }\n        }\n        return hasDt || hasDd;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "When not empty, element has both <dt> and <dd> elements",
          "fail": "When not empty, element does not have at least one <dt> element followed by at least one <dd> element"
        }
      }
    },
    {
      "id": "only-dlitems",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons13 = axe.commons, dom = _axe$commons13.dom, aria = _axe$commons13.aria;\n        var ALLOWED_ROLES = [ 'definition', 'term', 'list' ];\n        var base = {\n          badNodes: [],\n          hasNonEmptyTextNode: false\n        };\n        var content = virtualNode.children.reduce(function(content, child) {\n          var actualNode = child.actualNode;\n          if (actualNode.nodeName.toUpperCase() === 'DIV' && aria.getRole(actualNode) === null) {\n            return content.concat(child.children);\n          }\n          return content.concat(child);\n        }, []);\n        var result = content.reduce(function(out, childNode) {\n          var actualNode = childNode.actualNode;\n          var tagName = actualNode.nodeName.toUpperCase();\n          if (actualNode.nodeType === 1 && dom.isVisible(actualNode, true, false)) {\n            var explicitRole = aria.getRole(actualNode, {\n              noImplicit: true\n            });\n            if (tagName !== 'DT' && tagName !== 'DD' || explicitRole) {\n              if (!ALLOWED_ROLES.includes(explicitRole)) {\n                out.badNodes.push(actualNode);\n              }\n            }\n          } else if (actualNode.nodeType === 3 && actualNode.nodeValue.trim() !== '') {\n            out.hasNonEmptyTextNode = true;\n          }\n          return out;\n        }, base);\n        if (result.badNodes.length) {\n          this.relatedNodes(result.badNodes);\n        }\n        return !!result.badNodes.length || result.hasNonEmptyTextNode;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "List element only has direct children that are allowed inside <dt> or <dd> elements",
          "fail": "List element has direct children that are not allowed inside <dt> or <dd> elements"
        }
      }
    },
    {
      "id": "dlitem",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var parent = axe.commons.dom.getComposedParent(node);\n        var parentTagName = parent.nodeName.toUpperCase();\n        var parentRole = axe.commons.aria.getRole(parent, {\n          noImplicit: true\n        });\n        if (parentTagName === 'DIV' && [ 'presentation', 'none', null ].includes(parentRole)) {\n          parent = axe.commons.dom.getComposedParent(parent);\n          parentTagName = parent.nodeName.toUpperCase();\n          parentRole = axe.commons.aria.getRole(parent, {\n            noImplicit: true\n          });\n        }\n        if (parentTagName !== 'DL') {\n          return false;\n        }\n        if (!parentRole || parentRole === 'list') {\n          return true;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Description list item has a <dl> parent element",
          "fail": "Description list item does not have a <dl> parent element"
        }
      }
    },
    {
      "id": "doc-has-title",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var title = document.title;\n        return !!(title ? axe.commons.text.sanitize(title).trim() : '');\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Document has a non-empty <title> element",
          "fail": "Document does not have a non-empty <title> element"
        }
      }
    },
    {
      "id": "duplicate-id-active",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var id = node.getAttribute('id').trim();\n        if (!id) {\n          return true;\n        }\n        var root = axe.commons.dom.getRootNode(node);\n        var matchingNodes = Array.from(root.querySelectorAll('[id=\"'.concat(axe.utils.escapeSelector(id), '\"]'))).filter(function(foundNode) {\n          return foundNode !== node;\n        });\n        if (matchingNodes.length) {\n          this.relatedNodes(matchingNodes);\n        }\n        this.data(id);\n        return matchingNodes.length === 0;\n      }",
      "after": "function after(results, options) {\n        var uniqueIds = [];\n        return results.filter(function(r) {\n          if (uniqueIds.indexOf(r.data) === -1) {\n            uniqueIds.push(r.data);\n            return true;\n          }\n          return false;\n        });\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Document has no active elements that share the same id attribute",
          "fail": "Document has active elements with the same id attribute: ${data}"
        }
      }
    },
    {
      "id": "duplicate-id-aria",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var id = node.getAttribute('id').trim();\n        if (!id) {\n          return true;\n        }\n        var root = axe.commons.dom.getRootNode(node);\n        var matchingNodes = Array.from(root.querySelectorAll('[id=\"'.concat(axe.utils.escapeSelector(id), '\"]'))).filter(function(foundNode) {\n          return foundNode !== node;\n        });\n        if (matchingNodes.length) {\n          this.relatedNodes(matchingNodes);\n        }\n        this.data(id);\n        return matchingNodes.length === 0;\n      }",
      "after": "function after(results, options) {\n        var uniqueIds = [];\n        return results.filter(function(r) {\n          if (uniqueIds.indexOf(r.data) === -1) {\n            uniqueIds.push(r.data);\n            return true;\n          }\n          return false;\n        });\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Document has no elements referenced with ARIA or labels that share the same id attribute",
          "fail": "Document has multiple elements referenced with ARIA with the same id attribute: ${data}"
        }
      }
    },
    {
      "id": "duplicate-id",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var id = node.getAttribute('id').trim();\n        if (!id) {\n          return true;\n        }\n        var root = axe.commons.dom.getRootNode(node);\n        var matchingNodes = Array.from(root.querySelectorAll('[id=\"'.concat(axe.utils.escapeSelector(id), '\"]'))).filter(function(foundNode) {\n          return foundNode !== node;\n        });\n        if (matchingNodes.length) {\n          this.relatedNodes(matchingNodes);\n        }\n        this.data(id);\n        return matchingNodes.length === 0;\n      }",
      "after": "function after(results, options) {\n        var uniqueIds = [];\n        return results.filter(function(r) {\n          if (uniqueIds.indexOf(r.data) === -1) {\n            uniqueIds.push(r.data);\n            return true;\n          }\n          return false;\n        });\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Document has no static elements that share the same id attribute",
          "fail": "Document has multiple static elements with the same id attribute"
        }
      }
    },
    {
      "id": "has-widget-role",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var role = node.getAttribute('role');\n        if (role === null) {\n          return false;\n        }\n        var roleType = axe.commons.aria.getRoleType(role);\n        return roleType === 'widget' || roleType === 'composite';\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Element has a widget role.",
          "fail": "Element does not have a widget role."
        }
      }
    },
    {
      "id": "valid-scrollable-semantics",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var VALID_TAG_NAMES_FOR_SCROLLABLE_REGIONS = {\n          ARTICLE: true,\n          ASIDE: true,\n          NAV: true,\n          SECTION: true\n        };\n        var VALID_ROLES_FOR_SCROLLABLE_REGIONS = {\n          application: true,\n          banner: false,\n          complementary: true,\n          contentinfo: true,\n          form: true,\n          main: true,\n          navigation: true,\n          region: true,\n          search: false\n        };\n        function validScrollableTagName(node) {\n          var nodeName = node.nodeName.toUpperCase();\n          return VALID_TAG_NAMES_FOR_SCROLLABLE_REGIONS[nodeName] || false;\n        }\n        function validScrollableRole(node) {\n          var role = node.getAttribute('role');\n          if (!role) {\n            return false;\n          }\n          return VALID_ROLES_FOR_SCROLLABLE_REGIONS[role.toLowerCase()] || false;\n        }\n        function validScrollableSemantics(node) {\n          return validScrollableRole(node) || validScrollableTagName(node);\n        }\n        return validScrollableSemantics(node);\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Element has valid semantics for an element in the focus order.",
          "fail": "Element has invalid semantics for an element in the focus order."
        }
      }
    },
    {
      "id": "multiple-label",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var id = axe.utils.escapeSelector(node.getAttribute('id'));\n        var parent = node.parentNode;\n        var root = axe.commons.dom.getRootNode(node);\n        root = root.documentElement || root;\n        var labels = Array.from(root.querySelectorAll('label[for=\"'.concat(id, '\"]')));\n        if (labels.length) {\n          labels = labels.filter(function(label) {\n            return axe.commons.dom.isVisible(label);\n          });\n        }\n        while (parent) {\n          if (parent.nodeName.toUpperCase() === 'LABEL' && labels.indexOf(parent) === -1) {\n            labels.push(parent);\n          }\n          parent = parent.parentNode;\n        }\n        this.relatedNodes(labels);\n        if (labels.length > 1) {\n          var ATVisibleLabels = labels.filter(function(label) {\n            return axe.commons.dom.isVisible(label, true);\n          });\n          if (ATVisibleLabels.length > 1) {\n            return undefined;\n          }\n          var labelledby = axe.commons.dom.idrefs(node, 'aria-labelledby');\n          return !labelledby.includes(ATVisibleLabels[0]) ? undefined : false;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Form field does not have multiple label elements",
          "incomplete": "Multiple label elements is not widely supported in assistive technologies. Ensure the first label contains all necessary information."
        }
      }
    },
    {
      "id": "frame-tested",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var resolve = this.async();\n        var _Object$assign = Object.assign({\n          isViolation: false,\n          timeout: 500\n        }, options), isViolation = _Object$assign.isViolation, timeout = _Object$assign.timeout;\n        var timer = setTimeout(function() {\n          timer = setTimeout(function() {\n            timer = null;\n            resolve(isViolation ? false : undefined);\n          }, 0);\n        }, timeout);\n        axe.utils.respondable(node.contentWindow, 'axe.ping', null, undefined, function() {\n          if (timer !== null) {\n            clearTimeout(timer);\n            resolve(true);\n          }\n        });\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "The iframe was tested with axe-core",
          "fail": "The iframe could not be tested with axe-core",
          "incomplete": "The iframe still has to be tested with axe-core"
        }
      }
    },
    {
      "id": "unique-frame-title",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var title = axe.commons.text.sanitize(node.title).trim().toLowerCase();\n        this.data(title);\n        return true;\n      }",
      "after": "function after(results, options) {\n        var titles = {};\n        results.forEach(function(r) {\n          titles[r.data] = titles[r.data] !== undefined ? ++titles[r.data] : 0;\n        });\n        results.forEach(function(r) {\n          r.result = !!titles[r.data];\n        });\n        return results;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Element's title attribute is unique",
          "fail": "Element's title attribute is not unique"
        }
      }
    },
    {
      "id": "heading-order",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var ariaHeadingLevel = node.getAttribute('aria-level');\n        if (ariaHeadingLevel !== null) {\n          this.data(parseInt(ariaHeadingLevel, 10));\n          return true;\n        }\n        var headingLevel = node.nodeName.toUpperCase().match(/H(\\d)/);\n        if (headingLevel) {\n          this.data(parseInt(headingLevel[1], 10));\n          return true;\n        }\n        return true;\n      }",
      "after": "function after(results, options) {\n        if (results.length < 2) {\n          return results;\n        }\n        var prevLevel = results[0].data;\n        for (var i = 1; i < results.length; i++) {\n          if (results[i].result && results[i].data > prevLevel + 1) {\n            results[i].result = false;\n          }\n          prevLevel = results[i].data;\n        }\n        return results;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Heading order valid",
          "fail": "Heading order invalid"
        }
      }
    },
    {
      "id": "hidden-content",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var whitelist = [ 'SCRIPT', 'HEAD', 'TITLE', 'NOSCRIPT', 'STYLE', 'TEMPLATE' ];\n        if (!whitelist.includes(node.nodeName.toUpperCase()) && axe.commons.dom.hasContentVirtual(virtualNode)) {\n          var styles = window.getComputedStyle(node);\n          if (styles.getPropertyValue('display') === 'none') {\n            return undefined;\n          } else if (styles.getPropertyValue('visibility') === 'hidden') {\n            var parent = axe.commons.dom.getComposedParent(node);\n            var parentStyle = parent && window.getComputedStyle(parent);\n            if (!parentStyle || parentStyle.getPropertyValue('visibility') !== 'hidden') {\n              return undefined;\n            }\n          }\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "All content on the page has been analyzed.",
          "fail": "There were problems analyzing the content on this page.",
          "incomplete": "There is hidden content on the page that was not analyzed. You will need to trigger the display of this content in order to analyze it."
        }
      }
    },
    {
      "id": "has-lang",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var isXHTML = axe.utils.isXHTML;\n        var langValue = (node.getAttribute('lang') || '').trim();\n        var xmlLangValue = (node.getAttribute('xml:lang') || '').trim();\n        if (!langValue && !isXHTML(document)) {\n          return false;\n        }\n        return !!(langValue || xmlLangValue);\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "The <html> element has a lang attribute",
          "fail": "The <html> element does not have a lang attribute"
        }
      }
    },
    {
      "id": "valid-lang",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var langs, invalid;\n        langs = (options ? options : axe.utils.validLangs()).map(axe.utils.getBaseLang);\n        invalid = [ 'lang', 'xml:lang' ].reduce(function(invalid, langAttr) {\n          var langVal = node.getAttribute(langAttr);\n          if (typeof langVal !== 'string') {\n            return invalid;\n          }\n          var baselangVal = axe.utils.getBaseLang(langVal);\n          if (baselangVal !== '' && langs.indexOf(baselangVal) === -1) {\n            invalid.push(langAttr + '=\"' + node.getAttribute(langAttr) + '\"');\n          }\n          return invalid;\n        }, []);\n        if (invalid.length) {\n          this.data(invalid);\n          return true;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Value of lang attribute is included in the list of valid languages",
          "fail": "Value of lang attribute not included in the list of valid languages"
        }
      }
    },
    {
      "id": "xml-lang-mismatch",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var getBaseLang = axe.utils.getBaseLang;\n        var primaryLangValue = getBaseLang(node.getAttribute('lang'));\n        var primaryXmlLangValue = getBaseLang(node.getAttribute('xml:lang'));\n        return primaryLangValue === primaryXmlLangValue;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Lang and xml:lang attributes have the same base language",
          "fail": "Lang and xml:lang attributes do not have the same base language"
        }
      }
    },
    {
      "id": "identical-links-same-purpose",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons15 = axe.commons, dom = _axe$commons15.dom, text = _axe$commons15.text;\n        var accText = text.accessibleTextVirtual(virtualNode);\n        var name = text.sanitize(text.removeUnicode(accText, {\n          emoji: true,\n          nonBmp: true,\n          punctuations: true\n        })).toLowerCase();\n        if (!name) {\n          return undefined;\n        }\n        var afterData = {\n          name: name,\n          urlProps: dom.urlPropsFromAttribute(node, 'href')\n        };\n        this.data(afterData);\n        this.relatedNodes([ node ]);\n        return true;\n      }",
      "after": "function after(results, options) {\n        if (results.length < 2) {\n          return results;\n        }\n        var incompleteResults = results.filter(function(_ref17) {\n          var result = _ref17.result;\n          return result !== undefined;\n        });\n        var uniqueResults = [];\n        var nameMap = {};\n        var _loop2 = function _loop2(index) {\n          var _currentResult$relate;\n          var currentResult = incompleteResults[index];\n          var _currentResult$data = currentResult.data, name = _currentResult$data.name, urlProps = _currentResult$data.urlProps;\n          if (nameMap[name]) {\n            return 'continue';\n          }\n          var sameNameResults = incompleteResults.filter(function(_ref18, resultNum) {\n            var data = _ref18.data;\n            return data.name === name && resultNum !== index;\n          });\n          var isSameUrl = sameNameResults.every(function(_ref19) {\n            var data = _ref19.data;\n            return isIdenticalObject(data.urlProps, urlProps);\n          });\n          if (sameNameResults.length && !isSameUrl) {\n            currentResult.result = undefined;\n          }\n          currentResult.relatedNodes = [];\n          (_currentResult$relate = currentResult.relatedNodes).push.apply(_currentResult$relate, _toConsumableArray(sameNameResults.map(function(node) {\n            return node.relatedNodes[0];\n          })));\n          nameMap[name] = sameNameResults;\n          uniqueResults.push(currentResult);\n        };\n        for (var index = 0; index < incompleteResults.length; index++) {\n          var _ret2 = _loop2(index);\n          if (_ret2 === 'continue') {\n            continue;\n          }\n        }\n        return uniqueResults;\n        function isIdenticalObject(a, b) {\n          if (!a || !b) {\n            return false;\n          }\n          var aProps = Object.getOwnPropertyNames(a);\n          var bProps = Object.getOwnPropertyNames(b);\n          if (aProps.length !== bProps.length) {\n            return false;\n          }\n          var result = aProps.every(function(propName) {\n            var aValue = a[propName];\n            var bValue = b[propName];\n            if (_typeof(aValue) !== _typeof(bValue)) {\n              return false;\n            }\n            if (typeof aValue === 'object' || typeof bValue === 'object') {\n              return isIdenticalObject(aValue, bValue);\n            }\n            return aValue === bValue;\n          });\n          return result;\n        }\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "There are no other links with the same name, that go to a different URL",
          "incomplete": "Check that links have the same purpose, or are intentionally ambiguous."
        }
      }
    },
    {
      "id": "has-alt",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var nodeName = virtualNode.props.nodeName;\n        if (![ 'img', 'input', 'area' ].includes(nodeName)) {\n          return false;\n        }\n        return virtualNode.hasAttr('alt');\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Element has an alt attribute",
          "fail": "Element does not have an alt attribute"
        }
      }
    },
    {
      "id": "alt-space-value",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var alt = virtualNode.attr('alt');\n        var isOnlySpace = /^\\s+$/;\n        return typeof alt === 'string' && isOnlySpace.test(alt);\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Element has a valid alt attribute value",
          "fail": "Element has an alt attribute containing only a space character, which is not ignored by all screen readers"
        }
      }
    },
    {
      "id": "duplicate-img-label",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons11 = axe.commons, aria = _axe$commons11.aria, text = _axe$commons11.text, dom = _axe$commons11.dom;\n        if ([ 'none', 'presentation' ].includes(aria.getRole(node))) {\n          return false;\n        }\n        var parent = dom.findUpVirtual(virtualNode, 'button, [role=\"button\"], a[href], p, li, td, th');\n        if (!parent) {\n          return false;\n        }\n        var parentVNode = axe.utils.getNodeFromTree(parent);\n        var visibleText = text.visibleVirtual(parentVNode, true).toLowerCase();\n        if (visibleText === '') {\n          return false;\n        }\n        return visibleText === text.accessibleTextVirtual(virtualNode).toLowerCase();\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Element does not duplicate existing text in <img> alt text",
          "fail": "Element contains <img> element with alt text that duplicates existing text"
        }
      }
    },
    {
      "id": "non-empty-if-present",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var nodeName = node.nodeName.toUpperCase();\n        var type = (node.getAttribute('type') || '').toLowerCase();\n        var label = node.getAttribute('value');\n        if (label) {\n          this.data({\n            messageKey: 'has-label'\n          });\n        }\n        if (nodeName === 'INPUT' && [ 'submit', 'reset' ].includes(type)) {\n          return label === null;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": {
            "default": "Element does not have a value attribute",
            "has-label": "Element has a non-empty value attribute"
          },
          "fail": "Element has a value attribute and the value attribute is empty"
        }
      }
    },
    {
      "id": "non-empty-value",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var label = node.getAttribute('value');\n        return !!(label ? axe.commons.text.sanitize(label).trim() : '');\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Element has a non-empty value attribute",
          "fail": "Element has no value attribute or the value attribute is empty"
        }
      }
    },
    {
      "id": "label-content-name-mismatch",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var text = axe.commons.text;\n        var _ref6 = options || {}, pixelThreshold = _ref6.pixelThreshold, occuranceThreshold = _ref6.occuranceThreshold;\n        var accText = text.accessibleText(node).toLowerCase();\n        if (text.isHumanInterpretable(accText) < 1) {\n          return undefined;\n        }\n        var textVNodes = text.visibleTextNodes(virtualNode);\n        var nonLigatureText = textVNodes.filter(function(textVNode) {\n          return !text.isIconLigature(textVNode, pixelThreshold, occuranceThreshold);\n        }).map(function(textVNode) {\n          return textVNode.actualNode.nodeValue;\n        }).join('');\n        var visibleText = text.sanitize(nonLigatureText).toLowerCase();\n        if (!visibleText) {\n          return true;\n        }\n        if (text.isHumanInterpretable(visibleText) < 1) {\n          if (isStringContained(visibleText, accText)) {\n            return true;\n          }\n          return undefined;\n        }\n        return isStringContained(visibleText, accText);\n        function isStringContained(compare, compareWith) {\n          var curatedCompareWith = curateString(compareWith);\n          var curatedCompare = curateString(compare);\n          if (!curatedCompareWith || !curatedCompare) {\n            return false;\n          }\n          return curatedCompareWith.includes(curatedCompare);\n        }\n        function curateString(str) {\n          var noUnicodeStr = text.removeUnicode(str, {\n            emoji: true,\n            nonBmp: true,\n            punctuations: true\n          });\n          return text.sanitize(noUnicodeStr);\n        }\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Element contains visible text as part of it's accessible name",
          "fail": "Text inside the element is not included in the accessible name"
        }
      }
    },
    {
      "id": "title-only",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var labelText = axe.commons.text.labelVirtual(virtualNode);\n        return !labelText && !!(node.getAttribute('title') || node.getAttribute('aria-describedby'));\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Form element does not solely use title attribute for its label",
          "fail": "Only title used to generate label for form element"
        }
      }
    },
    {
      "id": "implicit-label",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons12 = axe.commons, dom = _axe$commons12.dom, text = _axe$commons12.text;\n        var label = dom.findUpVirtual(virtualNode, 'label');\n        if (label) {\n          return !!text.accessibleText(label, {\n            inControlContext: true\n          });\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Form element has an implicit (wrapped) <label>",
          "fail": "Form element does not have an implicit (wrapped) <label>"
        }
      }
    },
    {
      "id": "explicit-label",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (node.getAttribute('id')) {\n          var root = axe.commons.dom.getRootNode(node);\n          var id = axe.utils.escapeSelector(node.getAttribute('id'));\n          var label = root.querySelector('label[for=\"'.concat(id, '\"]'));\n          if (label) {\n            if (!axe.commons.dom.isVisible(label)) {\n              return true;\n            } else {\n              return !!axe.commons.text.accessibleText(label);\n            }\n          }\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Form element has an explicit <label>",
          "fail": "Form element does not have an explicit <label>"
        }
      }
    },
    {
      "id": "help-same-as-label",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var labelText = axe.commons.text.labelVirtual(virtualNode), check = node.getAttribute('title');\n        if (!labelText) {\n          return false;\n        }\n        if (!check) {\n          check = '';\n          if (node.getAttribute('aria-describedby')) {\n            var ref = axe.commons.dom.idrefs(node, 'aria-describedby');\n            check = ref.map(function(thing) {\n              return thing ? axe.commons.text.accessibleText(thing) : '';\n            }).join('');\n          }\n        }\n        return axe.commons.text.sanitize(check) === axe.commons.text.sanitize(labelText);\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Help text (title or aria-describedby) does not duplicate label text",
          "fail": "Help text (title or aria-describedby) text is the same as the label text"
        }
      }
    },
    {
      "id": "hidden-explicit-label",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (node.getAttribute('id')) {\n          var root = axe.commons.dom.getRootNode(node);\n          var id = axe.utils.escapeSelector(node.getAttribute('id'));\n          var label = root.querySelector('label[for=\"'.concat(id, '\"]'));\n          if (label && !axe.commons.dom.isVisible(label, true)) {\n            var name = axe.commons.text.accessibleTextVirtual(virtualNode).trim();\n            var isNameEmpty = name === '';\n            return isNameEmpty;\n          }\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Form element has a visible explicit <label>",
          "fail": "Form element has explicit <label> that is hidden"
        }
      }
    },
    {
      "id": "landmark-is-top-level",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var landmarks = axe.commons.aria.getRolesByType('landmark');\n        var parent = axe.commons.dom.getComposedParent(node);\n        this.data({\n          role: node.getAttribute('role') || axe.commons.aria.implicitRole(node)\n        });\n        while (parent) {\n          var role = parent.getAttribute('role');\n          if (!role && parent.nodeName.toUpperCase() !== 'FORM') {\n            role = axe.commons.aria.implicitRole(parent);\n          }\n          if (role && landmarks.includes(role)) {\n            return false;\n          }\n          parent = axe.commons.dom.getComposedParent(parent);\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "The ${data.role} landmark is at the top level.",
          "fail": "The ${data.role} landmark is contained in another landmark."
        }
      }
    },
    {
      "id": "page-no-duplicate-banner",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var key = 'page-no-duplicate;' + options.selector;\n        if (axe._cache.get(key)) {\n          this.data('ignored');\n          return;\n        }\n        axe._cache.set(key, true);\n        var elms = axe.utils.querySelectorAllFilter(axe._tree[0], options.selector, function(elm) {\n          return elm !== virtualNode && axe.commons.dom.isVisible(elm.actualNode);\n        });\n        if (typeof options.nativeScopeFilter === 'string') {\n          elms = elms.filter(function(elm) {\n            return elm.actualNode.hasAttribute('role') || !axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter);\n          });\n        }\n        this.relatedNodes(elms.map(function(elm) {\n          return elm.actualNode;\n        }));\n        return elms.length === 0;\n      }",
      "after": "function after(results, options) {\n        return results.filter(function(checkResult) {\n          return checkResult.data !== 'ignored';\n        });\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Document does not have more than one banner landmark",
          "fail": "Document has more than one banner landmark"
        }
      }
    },
    {
      "id": "page-no-duplicate-contentinfo",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var key = 'page-no-duplicate;' + options.selector;\n        if (axe._cache.get(key)) {\n          this.data('ignored');\n          return;\n        }\n        axe._cache.set(key, true);\n        var elms = axe.utils.querySelectorAllFilter(axe._tree[0], options.selector, function(elm) {\n          return elm !== virtualNode && axe.commons.dom.isVisible(elm.actualNode);\n        });\n        if (typeof options.nativeScopeFilter === 'string') {\n          elms = elms.filter(function(elm) {\n            return elm.actualNode.hasAttribute('role') || !axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter);\n          });\n        }\n        this.relatedNodes(elms.map(function(elm) {\n          return elm.actualNode;\n        }));\n        return elms.length === 0;\n      }",
      "after": "function after(results, options) {\n        return results.filter(function(checkResult) {\n          return checkResult.data !== 'ignored';\n        });\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Document does not have more than one contentinfo landmark",
          "fail": "Document has more than one contentinfo landmark"
        }
      }
    },
    {
      "id": "page-no-duplicate-main",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var key = 'page-no-duplicate;' + options.selector;\n        if (axe._cache.get(key)) {\n          this.data('ignored');\n          return;\n        }\n        axe._cache.set(key, true);\n        var elms = axe.utils.querySelectorAllFilter(axe._tree[0], options.selector, function(elm) {\n          return elm !== virtualNode && axe.commons.dom.isVisible(elm.actualNode);\n        });\n        if (typeof options.nativeScopeFilter === 'string') {\n          elms = elms.filter(function(elm) {\n            return elm.actualNode.hasAttribute('role') || !axe.commons.dom.findUpVirtual(elm, options.nativeScopeFilter);\n          });\n        }\n        this.relatedNodes(elms.map(function(elm) {\n          return elm.actualNode;\n        }));\n        return elms.length === 0;\n      }",
      "after": "function after(results, options) {\n        return results.filter(function(checkResult) {\n          return checkResult.data !== 'ignored';\n        });\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Document does not have more than one main landmark",
          "fail": "Document has more than one main landmark"
        }
      }
    },
    {
      "id": "page-has-main",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var matchingElms = axe.utils.querySelectorAllFilter(virtualNode, options.selector, function(vNode) {\n          return axe.commons.dom.isVisible(vNode.actualNode, true);\n        });\n        this.relatedNodes(matchingElms.map(function(vNode) {\n          return vNode.actualNode;\n        }));\n        return matchingElms.length > 0;\n      }",
      "after": "function after(results, options) {\n        var elmUsedAnywhere = results.some(function(frameResult) {\n          return frameResult.result === true;\n        });\n        if (elmUsedAnywhere) {\n          results.forEach(function(result) {\n            result.result = true;\n          });\n        }\n        return results;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Document has at least one main landmark",
          "fail": "Document does not have a main landmark"
        }
      }
    },
    {
      "id": "landmark-is-unique",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var role = axe.commons.aria.getRole(node);\n        var accessibleText = axe.commons.text.accessibleTextVirtual(virtualNode);\n        accessibleText = accessibleText ? accessibleText.toLowerCase() : null;\n        this.data({\n          role: role,\n          accessibleText: accessibleText\n        });\n        this.relatedNodes([ node ]);\n        return true;\n      }",
      "after": "function after(results, options) {\n        var uniqueLandmarks = [];\n        return results.filter(function(currentResult) {\n          var findMatch = function findMatch(someResult) {\n            return currentResult.data.role === someResult.data.role && currentResult.data.accessibleText === someResult.data.accessibleText;\n          };\n          var matchedResult = uniqueLandmarks.find(findMatch);\n          if (matchedResult) {\n            matchedResult.result = false;\n            matchedResult.relatedNodes.push(currentResult.relatedNodes[0]);\n            return false;\n          }\n          uniqueLandmarks.push(currentResult);\n          currentResult.relatedNodes = [];\n          return true;\n        });\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Landmarks must have a unique role or role/label/title (i.e. accessible name) combination",
          "fail": "The landmark must have a unique aria-label, aria-labelledby, or title to make landmarks distinguishable"
        }
      }
    },
    {
      "id": "has-th",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var row, cell, badCells = [];\n        for (var rowIndex = 0, rowLength = node.rows.length; rowIndex < rowLength; rowIndex++) {\n          row = node.rows[rowIndex];\n          for (var cellIndex = 0, cellLength = row.cells.length; cellIndex < cellLength; cellIndex++) {\n            cell = row.cells[cellIndex];\n            if (cell.nodeName.toUpperCase() === 'TH' || [ 'rowheader', 'columnheader' ].indexOf(cell.getAttribute('role')) !== -1) {\n              badCells.push(cell);\n            }\n          }\n        }\n        if (badCells.length) {\n          this.relatedNodes(badCells);\n          return true;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Layout table does not use <th> elements",
          "fail": "Layout table uses <th> elements"
        }
      }
    },
    {
      "id": "has-caption",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!node.caption;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Layout table does not use <caption> element",
          "fail": "Layout table uses <caption> element"
        }
      }
    },
    {
      "id": "has-summary",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!node.summary;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Layout table does not use summary attribute",
          "fail": "Layout table uses summary attribute"
        }
      }
    },
    {
      "id": "link-in-text-block",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons9 = axe.commons, color = _axe$commons9.color, dom = _axe$commons9.dom;\n        function getContrast(color1, color2) {\n          var c1lum = color1.getRelativeLuminance();\n          var c2lum = color2.getRelativeLuminance();\n          return (Math.max(c1lum, c2lum) + .05) / (Math.min(c1lum, c2lum) + .05);\n        }\n        var blockLike = [ 'block', 'list-item', 'table', 'flex', 'grid', 'inline-block' ];\n        function isBlock(elm) {\n          var display = window.getComputedStyle(elm).getPropertyValue('display');\n          return blockLike.indexOf(display) !== -1 || display.substr(0, 6) === 'table-';\n        }\n        if (isBlock(node)) {\n          return false;\n        }\n        var parentBlock = dom.getComposedParent(node);\n        while (parentBlock.nodeType === 1 && !isBlock(parentBlock)) {\n          parentBlock = dom.getComposedParent(parentBlock);\n        }\n        this.relatedNodes([ parentBlock ]);\n        if (color.elementIsDistinct(node, parentBlock)) {\n          return true;\n        } else {\n          var nodeColor, parentColor;\n          nodeColor = color.getForegroundColor(node);\n          parentColor = color.getForegroundColor(parentBlock);\n          if (!nodeColor || !parentColor) {\n            return undefined;\n          }\n          var contrast = getContrast(nodeColor, parentColor);\n          if (contrast === 1) {\n            return true;\n          } else if (contrast >= 3) {\n            axe.commons.color.incompleteData.set('fgColor', 'bgContrast');\n            this.data({\n              messageKey: axe.commons.color.incompleteData.get('fgColor')\n            });\n            axe.commons.color.incompleteData.clear();\n            return undefined;\n          }\n          nodeColor = color.getBackgroundColor(node);\n          parentColor = color.getBackgroundColor(parentBlock);\n          if (!nodeColor || !parentColor || getContrast(nodeColor, parentColor) >= 3) {\n            var reason;\n            if (!nodeColor || !parentColor) {\n              reason = axe.commons.color.incompleteData.get('bgColor');\n            } else {\n              reason = 'bgContrast';\n            }\n            axe.commons.color.incompleteData.set('fgColor', reason);\n            this.data({\n              messageKey: axe.commons.color.incompleteData.get('fgColor')\n            });\n            axe.commons.color.incompleteData.clear();\n            return undefined;\n          }\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Links can be distinguished from surrounding text in some way other than by color",
          "fail": "Links need to be distinguished from surrounding text in some way other than by color",
          "incomplete": {
            "default": "Unable to determine contrast ratio",
            "bgContrast": "Element's contrast ratio could not be determined. Check for a distinct hover/focus style",
            "bgImage": "Element's contrast ratio could not be determined due to a background image",
            "bgGradient": "Element's contrast ratio could not be determined due to a background gradient",
            "imgNode": "Element's contrast ratio could not be determined because element contains an image node",
            "bgOverlap": "Element's contrast ratio could not be determined because of element overlap"
          }
        }
      }
    },
    {
      "id": "focusable-no-name",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tabIndex = node.getAttribute('tabindex'), inFocusOrder = axe.commons.dom.isFocusable(node) && tabIndex > -1;\n        if (!inFocusOrder) {\n          return false;\n        }\n        return !axe.commons.text.accessibleTextVirtual(virtualNode);\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Element is not in tab order or has accessible text",
          "fail": "Element is in tab order and does not have accessible text"
        }
      }
    },
    {
      "id": "only-listitems",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons14 = axe.commons, dom = _axe$commons14.dom, aria = _axe$commons14.aria;\n        var hasNonEmptyTextNode = false;\n        var atLeastOneListitem = false;\n        var isEmpty = true;\n        var badNodes = [];\n        var badRoleNodes = [];\n        var badRoles = [];\n        virtualNode.children.forEach(function(vNode) {\n          var actualNode = vNode.actualNode;\n          if (actualNode.nodeType === 3 && actualNode.nodeValue.trim() !== '') {\n            hasNonEmptyTextNode = true;\n            return;\n          }\n          if (actualNode.nodeType !== 1 || !dom.isVisible(actualNode, true, false)) {\n            return;\n          }\n          isEmpty = false;\n          var isLi = actualNode.nodeName.toUpperCase() === 'LI';\n          var role = aria.getRole(vNode);\n          var isListItemRole = role === 'listitem';\n          if (!isLi && !isListItemRole) {\n            badNodes.push(actualNode);\n          }\n          if (isLi && !isListItemRole) {\n            badRoleNodes.push(actualNode);\n            if (!badRoles.includes(role)) {\n              badRoles.push(role);\n            }\n          }\n          if (isListItemRole) {\n            atLeastOneListitem = true;\n          }\n        });\n        if (hasNonEmptyTextNode || badNodes.length) {\n          this.relatedNodes(badNodes);\n          return true;\n        }\n        if (isEmpty || atLeastOneListitem) {\n          return false;\n        }\n        this.relatedNodes(badRoleNodes);\n        this.data({\n          messageKey: 'roleNotValid',\n          roles: badRoles.join(', ')\n        });\n        return true;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "List element only has direct children that are allowed inside <li> elements",
          "fail": {
            "default": "List element has direct children that are not allowed inside <li> elements",
            "roleNotValid": "List element has direct children with a role that is not allowed: ${data.roles}"
          }
        }
      }
    },
    {
      "id": "listitem",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var parent = axe.commons.dom.getComposedParent(node);\n        if (!parent) {\n          return undefined;\n        }\n        var parentTagName = parent.nodeName.toUpperCase();\n        var parentRole = (parent.getAttribute('role') || '').toLowerCase();\n        if (parentRole === 'list') {\n          return true;\n        }\n        if (parentRole && axe.commons.aria.isValidRole(parentRole)) {\n          this.data({\n            messageKey: 'roleNotValid'\n          });\n          return false;\n        }\n        return [ 'UL', 'OL' ].includes(parentTagName);\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "List item has a <ul>, <ol> or role=\"list\" parent element",
          "fail": {
            "default": "List item does not have a <ul>, <ol> parent element",
            "roleNotValid": "List item does not have a <ul>, <ol> parent element without a role, or a role=\"list\""
          }
        }
      }
    },
    {
      "id": "meta-refresh",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var content = node.getAttribute('content') || '', parsedParams = content.split(/[;,]/);\n        return content === '' || parsedParams[0] === '0';\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "<meta> tag does not immediately refresh the page",
          "fail": "<meta> tag forces timed refresh of page"
        }
      }
    },
    {
      "id": "meta-viewport-large",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var params, content = node.getAttribute('content') || '', parsedParams = content.split(/[;,]/), result = {}, minimum = options.scaleMinimum || 2, lowerBound = options.lowerBound || false;\n        for (var i = 0, l = parsedParams.length; i < l; i++) {\n          params = parsedParams[i].split('=');\n          var key = params.shift().toLowerCase();\n          if (key && params.length) {\n            result[key.trim()] = params.shift().trim().toLowerCase();\n          }\n        }\n        if (lowerBound && result['maximum-scale'] && parseFloat(result['maximum-scale']) < lowerBound) {\n          return true;\n        }\n        if (!lowerBound && result['user-scalable'] === 'no') {\n          this.data('user-scalable=no');\n          return false;\n        }\n        if (result['maximum-scale'] && parseFloat(result['maximum-scale']) < minimum) {\n          this.data('maximum-scale');\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "<meta> tag does not prevent significant zooming on mobile devices",
          "fail": "<meta> tag limits zooming on mobile devices"
        }
      }
    },
    {
      "id": "meta-viewport",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var params, content = node.getAttribute('content') || '', parsedParams = content.split(/[;,]/), result = {}, minimum = options.scaleMinimum || 2, lowerBound = options.lowerBound || false;\n        for (var i = 0, l = parsedParams.length; i < l; i++) {\n          params = parsedParams[i].split('=');\n          var key = params.shift().toLowerCase();\n          if (key && params.length) {\n            result[key.trim()] = params.shift().trim().toLowerCase();\n          }\n        }\n        if (lowerBound && result['maximum-scale'] && parseFloat(result['maximum-scale']) < lowerBound) {\n          return true;\n        }\n        if (!lowerBound && result['user-scalable'] === 'no') {\n          this.data('user-scalable=no');\n          return false;\n        }\n        if (result['maximum-scale'] && parseFloat(result['maximum-scale']) < minimum) {\n          this.data('maximum-scale');\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "<meta> tag does not disable zooming on mobile devices",
          "fail": "${data} on <meta> tag disables zooming on mobile devices"
        }
      }
    },
    {
      "id": "no-autoplay-audio",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!node.duration) {\n          console.warn('axe.utils.preloadMedia did not load metadata');\n          return undefined;\n        }\n        var _options$allowedDurat = options.allowedDuration, allowedDuration = _options$allowedDurat === void 0 ? 3 : _options$allowedDurat;\n        var playableDuration = getPlayableDuration(node);\n        if (playableDuration <= allowedDuration && !node.hasAttribute('loop')) {\n          return true;\n        }\n        if (!node.hasAttribute('controls')) {\n          return false;\n        }\n        return true;\n        function getPlayableDuration(elm) {\n          if (!elm.currentSrc) {\n            return 0;\n          }\n          var playbackRange = getPlaybackRange(elm.currentSrc);\n          if (!playbackRange) {\n            return Math.abs(elm.duration - (elm.currentTime || 0));\n          }\n          if (playbackRange.length === 1) {\n            return Math.abs(elm.duration - playbackRange[0]);\n          }\n          return Math.abs(playbackRange[1] - playbackRange[0]);\n        }\n        function getPlaybackRange(src) {\n          var match = src.match(/#t=(.*)/);\n          if (!match) {\n            return;\n          }\n          var _match = _slicedToArray(match, 2), value = _match[1];\n          var ranges = value.split(',');\n          return ranges.map(function(range) {\n            if (/:/.test(range)) {\n              return convertHourMinSecToSeconds(range);\n            }\n            return parseFloat(range);\n          });\n        }\n        function convertHourMinSecToSeconds(hhMmSs) {\n          var parts = hhMmSs.split(':');\n          var secs = 0;\n          var mins = 1;\n          while (parts.length > 0) {\n            secs += mins * parseInt(parts.pop(), 10);\n            mins *= 60;\n          }\n          return parseFloat(secs);\n        }\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "<video> or <audio> does not output audio for more than allowed duration or has controls mechanism",
          "fail": "<video> or <audio> outputs audio for more than allowed duration and does not have a controls mechanism",
          "incomplete": "Check that the <video> or <audio> does not output audio for more than allowed duration or provides a controls mechanism"
        }
      }
    },
    {
      "id": "p-as-heading",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var siblings = Array.from(node.parentNode.children);\n        var currentIndex = siblings.indexOf(node);\n        options = options || {};\n        var margins = options.margins || [];\n        var nextSibling = siblings.slice(currentIndex + 1).find(function(elm) {\n          return elm.nodeName.toUpperCase() === 'P';\n        });\n        var prevSibling = siblings.slice(0, currentIndex).reverse().find(function(elm) {\n          return elm.nodeName.toUpperCase() === 'P';\n        });\n        function getTextContainer(elm) {\n          var nextNode = elm;\n          var outerText = elm.textContent.trim();\n          var innerText = outerText;\n          while (innerText === outerText && nextNode !== undefined) {\n            var i = -1;\n            elm = nextNode;\n            if (elm.children.length === 0) {\n              return elm;\n            }\n            do {\n              i++;\n              innerText = elm.children[i].textContent.trim();\n            } while (innerText === '' && i + 1 < elm.children.length);\n            nextNode = elm.children[i];\n          }\n          return elm;\n        }\n        function normalizeFontWeight(weight) {\n          switch (weight) {\n           case 'lighter':\n            return 100;\n\n           case 'normal':\n            return 400;\n\n           case 'bold':\n            return 700;\n\n           case 'bolder':\n            return 900;\n          }\n          weight = parseInt(weight);\n          return !isNaN(weight) ? weight : 400;\n        }\n        function getStyleValues(node) {\n          var style = window.getComputedStyle(getTextContainer(node));\n          return {\n            fontWeight: normalizeFontWeight(style.getPropertyValue('font-weight')),\n            fontSize: parseInt(style.getPropertyValue('font-size')),\n            isItalic: style.getPropertyValue('font-style') === 'italic'\n          };\n        }\n        function isHeaderStyle(styleA, styleB, margins) {\n          return margins.reduce(function(out, margin) {\n            return out || (!margin.size || styleA.fontSize / margin.size > styleB.fontSize) && (!margin.weight || styleA.fontWeight - margin.weight > styleB.fontWeight) && (!margin.italic || styleA.isItalic && !styleB.isItalic);\n          }, false);\n        }\n        var currStyle = getStyleValues(node);\n        var nextStyle = nextSibling ? getStyleValues(nextSibling) : null;\n        var prevStyle = prevSibling ? getStyleValues(prevSibling) : null;\n        if (!nextStyle || !isHeaderStyle(currStyle, nextStyle, margins)) {\n          return true;\n        }\n        var blockquote = axe.commons.dom.findUpVirtual(virtualNode, 'blockquote');\n        if (blockquote && blockquote.nodeName.toUpperCase() === 'BLOCKQUOTE') {\n          return undefined;\n        }\n        if (prevStyle && !isHeaderStyle(currStyle, prevStyle, margins)) {\n          return undefined;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "<p> elements are not styled as headings",
          "fail": "Heading elements should be used instead of styled p elements"
        }
      }
    },
    {
      "id": "page-has-heading-one",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!options || !options.selector || typeof options.selector !== 'string') {\n          throw new TypeError('visible-in-page requires options.selector to be a string');\n        }\n        var matchingElms = axe.utils.querySelectorAllFilter(virtualNode, options.selector, function(vNode) {\n          return axe.commons.dom.isVisible(vNode.actualNode, true);\n        });\n        this.relatedNodes(matchingElms.map(function(vNode) {\n          return vNode.actualNode;\n        }));\n        return matchingElms.length > 0;\n      }",
      "after": "function after(results, options) {\n        var elmUsedAnywhere = results.some(function(frameResult) {\n          return frameResult.result === true;\n        });\n        if (elmUsedAnywhere) {\n          results.forEach(function(result) {\n            result.result = true;\n          });\n        }\n        return results;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Page has at least one level-one heading",
          "fail": "Page must have a level-one heading"
        }
      }
    },
    {
      "id": "region",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var _axe$commons16 = axe.commons, dom = _axe$commons16.dom, aria = _axe$commons16.aria;\n        var landmarkRoles = aria.getRolesByType('landmark');\n        var implicitAriaLiveRoles = [ 'alert', 'log', 'status' ];\n        var regionlessNodes = axe._cache.get('regionlessNodes');\n        if (regionlessNodes) {\n          return !regionlessNodes.includes(virtualNode);\n        }\n        var implicitLandmarks = landmarkRoles.reduce(function(arr, role) {\n          return arr.concat(aria.implicitNodes(role));\n        }, []).filter(function(r) {\n          return r !== null;\n        });\n        function isRegion(virtualNode) {\n          var node = virtualNode.actualNode;\n          var explicitRole = axe.commons.aria.getRole(node, {\n            noImplicit: true\n          });\n          var ariaLive = (node.getAttribute('aria-live') || '').toLowerCase().trim();\n          if ([ 'assertive', 'polite' ].includes(ariaLive) || implicitAriaLiveRoles.includes(explicitRole)) {\n            return true;\n          }\n          if (explicitRole) {\n            return explicitRole === 'dialog' || landmarkRoles.includes(explicitRole);\n          }\n          return implicitLandmarks.some(function(implicitSelector) {\n            var matches = axe.utils.matchesSelector(node, implicitSelector);\n            if (node.nodeName.toUpperCase() === 'FORM') {\n              var titleAttr = node.getAttribute('title');\n              var title = titleAttr && titleAttr.trim() !== '' ? axe.commons.text.sanitize(titleAttr) : null;\n              return matches && (!!aria.labelVirtual(virtualNode) || !!title);\n            }\n            return matches;\n          });\n        }\n        function findRegionlessElms(virtualNode) {\n          var node = virtualNode.actualNode;\n          if (isRegion(virtualNode) || dom.isSkipLink(virtualNode.actualNode) && dom.getElementByReference(virtualNode.actualNode, 'href') || !dom.isVisible(node, true)) {\n            var vNode = virtualNode;\n            while (vNode) {\n              vNode._hasRegionDescendant = true;\n              vNode = vNode.parent;\n            }\n            return [];\n          } else if (node !== document.body && dom.hasContent(node, true)) {\n            return [ virtualNode ];\n          } else {\n            return virtualNode.children.filter(function(_ref20) {\n              var actualNode = _ref20.actualNode;\n              return actualNode.nodeType === 1;\n            }).map(findRegionlessElms).reduce(function(a, b) {\n              return a.concat(b);\n            }, []);\n          }\n        }\n        regionlessNodes = findRegionlessElms(axe._tree[0]).map(function(vNode) {\n          while (vNode.parent && !vNode.parent._hasRegionDescendant && vNode.parent.actualNode !== document.body) {\n            vNode = vNode.parent;\n          }\n          return vNode;\n        }).filter(function(vNode, index, array) {\n          return array.indexOf(vNode) === index;\n        });\n        axe._cache.set('regionlessNodes', regionlessNodes);\n        return !regionlessNodes.includes(virtualNode);\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "All page content is contained by landmarks",
          "fail": "Some page content is not contained by landmarks"
        }
      }
    },
    {
      "id": "html5-scope",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        if (!axe.commons.dom.isHTML5(document)) {\n          return true;\n        }\n        return node.nodeName.toUpperCase() === 'TH';\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Scope attribute is only used on table header elements (<th>)",
          "fail": "In HTML 5, scope attributes may only be used on table header elements (<th>)"
        }
      }
    },
    {
      "id": "scope-value",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        options = options || {};\n        var value = node.getAttribute('scope').toLowerCase();\n        var validVals = [ 'row', 'col', 'rowgroup', 'colgroup' ] || options.values;\n        return validVals.indexOf(value) !== -1;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "Scope attribute is used correctly",
          "fail": "The value of the scope attribute may only be 'row' or 'col'"
        }
      }
    },
    {
      "id": "focusable-content",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tabbableElements = virtualNode.tabbableElements;\n        if (!tabbableElements) {\n          return false;\n        }\n        var tabbableContentElements = tabbableElements.filter(function(el) {\n          return el !== virtualNode;\n        });\n        return tabbableContentElements.length > 0;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Element contains focusable elements",
          "fail": "Element should have focusable content"
        }
      }
    },
    {
      "id": "focusable-element",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var isFocusable = virtualNode.isFocusable;\n        var tabIndex = parseInt(virtualNode.actualNode.getAttribute('tabindex'), 10);\n        tabIndex = !isNaN(tabIndex) ? tabIndex : null;\n        return tabIndex ? isFocusable && tabIndex >= 0 : isFocusable;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Element is focusable",
          "fail": "Element should be focusable"
        }
      }
    },
    {
      "id": "exists",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return undefined;\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Element does not exist",
          "incomplete": "Element exists"
        }
      }
    },
    {
      "id": "skip-link",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var target = axe.commons.dom.getElementByReference(node, 'href');\n        if (target) {\n          return axe.commons.dom.isVisible(target, true) || undefined;\n        }\n        return false;\n      }",
      "metadata": {
        "impact": "moderate",
        "messages": {
          "pass": "Skip link target exists",
          "incomplete": "Skip link target should become visible on activation",
          "fail": "No skip link target"
        }
      }
    },
    {
      "id": "svg-non-empty-title",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var titleNode = virtualNode.children.find(function(_ref21) {\n          var props = _ref21.props;\n          return props.nodeName === 'title';\n        });\n        return !!titleNode && titleNode.actualNode.textContent.trim() !== '';\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "element has a child that is a title",
          "fail": "element has no child that is a title"
        }
      }
    },
    {
      "id": "tabindex",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tabIndex = parseInt(node.getAttribute('tabindex'), 10);\n        return isNaN(tabIndex) ? true : tabIndex <= 0;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "Element does not have a tabindex greater than 0",
          "fail": "Element has a tabindex greater than 0"
        }
      }
    },
    {
      "id": "same-caption-summary",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        return !!(node.summary && node.caption) && node.summary.toLowerCase() === axe.commons.text.accessibleText(node.caption).toLowerCase();\n      }",
      "metadata": {
        "impact": "minor",
        "messages": {
          "pass": "Content of summary attribute and <caption> are not duplicated",
          "fail": "Content of summary attribute and <caption> element are identical"
        }
      }
    },
    {
      "id": "caption-faked",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var table = axe.commons.table.toGrid(node);\n        var firstRow = table[0];\n        if (table.length <= 1 || firstRow.length <= 1 || node.rows.length <= 1) {\n          return true;\n        }\n        return firstRow.reduce(function(out, curr, i) {\n          return out || curr !== firstRow[i + 1] && firstRow[i + 1] !== undefined;\n        }, false);\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "The first row of a table is not used as a caption",
          "fail": "The first child of the table should be a caption instead of a table cell"
        }
      }
    },
    {
      "id": "td-has-header",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tableUtils = axe.commons.table;\n        var badCells = [];\n        var cells = tableUtils.getAllCells(node);\n        var tableGrid = tableUtils.toGrid(node);\n        cells.forEach(function(cell) {\n          if (axe.commons.dom.hasContent(cell) && tableUtils.isDataCell(cell) && !axe.commons.aria.label(cell)) {\n            var hasHeaders = tableUtils.getHeaders(cell, tableGrid).some(function(header) {\n              return header !== null && !!axe.commons.dom.hasContent(header);\n            });\n            if (!hasHeaders) {\n              badCells.push(cell);\n            }\n          }\n        });\n        if (badCells.length) {\n          this.relatedNodes(badCells);\n          return false;\n        }\n        return true;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "All non-empty data cells have table headers",
          "fail": "Some non-empty data cells do not have table headers"
        }
      }
    },
    {
      "id": "td-headers-attr",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var cells = [];\n        for (var rowIndex = 0, rowLength = node.rows.length; rowIndex < rowLength; rowIndex++) {\n          var row = node.rows[rowIndex];\n          for (var cellIndex = 0, cellLength = row.cells.length; cellIndex < cellLength; cellIndex++) {\n            cells.push(row.cells[cellIndex]);\n          }\n        }\n        var ids = cells.reduce(function(ids, cell) {\n          if (cell.getAttribute('id')) {\n            ids.push(cell.getAttribute('id'));\n          }\n          return ids;\n        }, []);\n        var badCells = cells.reduce(function(badCells, cell) {\n          var isSelf, notOfTable;\n          var headers = (cell.getAttribute('headers') || '').split(/\\s/).reduce(function(headers, header) {\n            header = header.trim();\n            if (header) {\n              headers.push(header);\n            }\n            return headers;\n          }, []);\n          if (headers.length !== 0) {\n            if (cell.getAttribute('id')) {\n              isSelf = headers.indexOf(cell.getAttribute('id').trim()) !== -1;\n            }\n            notOfTable = headers.reduce(function(fail, header) {\n              return fail || ids.indexOf(header) === -1;\n            }, false);\n            if (isSelf || notOfTable) {\n              badCells.push(cell);\n            }\n          }\n          return badCells;\n        }, []);\n        if (badCells.length > 0) {\n          this.relatedNodes(badCells);\n          return false;\n        } else {\n          return true;\n        }\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "The headers attribute is exclusively used to refer to other cells in the table",
          "fail": "The headers attribute is not exclusively used to refer to other cells in the table"
        }
      }
    },
    {
      "id": "th-has-data-cells",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tableUtils = axe.commons.table;\n        var cells = tableUtils.getAllCells(node);\n        var checkResult = this;\n        var reffedHeaders = [];\n        cells.forEach(function(cell) {\n          var headers = cell.getAttribute('headers');\n          if (headers) {\n            reffedHeaders = reffedHeaders.concat(headers.split(/\\s+/));\n          }\n          var ariaLabel = cell.getAttribute('aria-labelledby');\n          if (ariaLabel) {\n            reffedHeaders = reffedHeaders.concat(ariaLabel.split(/\\s+/));\n          }\n        });\n        var headers = cells.filter(function(cell) {\n          if (axe.commons.text.sanitize(cell.textContent) === '') {\n            return false;\n          }\n          return cell.nodeName.toUpperCase() === 'TH' || [ 'rowheader', 'columnheader' ].indexOf(cell.getAttribute('role')) !== -1;\n        });\n        var tableGrid = tableUtils.toGrid(node);\n        var out = true;\n        headers.forEach(function(header) {\n          if (header.getAttribute('id') && reffedHeaders.includes(header.getAttribute('id'))) {\n            return;\n          }\n          var pos = tableUtils.getCellPosition(header, tableGrid);\n          var hasCell = false;\n          if (tableUtils.isColumnHeader(header)) {\n            hasCell = tableUtils.traverse('down', pos, tableGrid).find(function(cell) {\n              return !tableUtils.isColumnHeader(cell);\n            });\n          }\n          if (!hasCell && tableUtils.isRowHeader(header)) {\n            hasCell = tableUtils.traverse('right', pos, tableGrid).find(function(cell) {\n              return !tableUtils.isRowHeader(cell);\n            });\n          }\n          if (!hasCell) {\n            checkResult.relatedNodes(header);\n          }\n          out = out && hasCell;\n        });\n        return out ? true : undefined;\n      }",
      "metadata": {
        "impact": "serious",
        "messages": {
          "pass": "All table header cells refer to data cells",
          "fail": "Not all table header cells refer to data cells",
          "incomplete": "Table data cells are missing or empty"
        }
      }
    },
    {
      "id": "description",
      "enabled": true,
      "evaluate": "function evaluate(node, options, virtualNode, context) {\n        var tracks = axe.utils.querySelectorAll(virtualNode, 'track');\n        var hasDescriptions = tracks.some(function(_ref8) {\n          var actualNode = _ref8.actualNode;\n          return (actualNode.getAttribute('kind') || '').toLowerCase() === 'descriptions';\n        });\n        return hasDescriptions ? false : undefined;\n      }",
      "metadata": {
        "impact": "critical",
        "messages": {
          "pass": "The multimedia element has an audio description track",
          "incomplete": "Check that audio description is available for the element"
        }
      }
    }
  ],
  "disableOtherRules": true,
  "rulesetVersion": "2.11.0",
  "axeVersion": "3.5.1",
  "ver": "3.5.1"
}